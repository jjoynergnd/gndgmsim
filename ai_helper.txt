

******************* START OF FILES ***********************

src/screens/TeamPage.jsx:

import React, { useState } from "react";
import { useSelector } from "react-redux";

import { teams } from "../data/teams";
import seasonState from "../data/season/seasonState.json";
import { advanceSeason } from "../utils/seasonEngine";

import TeamHeader from "../components/team/TeamHeader";
import NextActionCard from "../components/season/NextActionCard";
import TeamTabs from "../components/team/TeamTabs";
import RosterTable from "../components/team/RosterTable";
import DepthChart from "../components/team/depthchart/DepthChart.jsx";
import StaffTable from "../components/team/StaffTable";
import FinancesPanel from "../components/team/FinancesPanel";
import StatsPanel from "../components/team/StatsPanel";
import PlayerModal from "../components/player/PlayerModal";
import ScheduleTab from "../components/team/schedule/ScheduleTab";
import DivisionStandings from "../components/standings/DivisionStandings";
import PlayoffsTab from "../components/team/playoffs/PlayoffsTab";


// dynamic imports
const rosterMap = import.meta.glob("../data/rosters/*.json", { eager: true });
const staffMap = import.meta.glob("../data/staff/*.json", { eager: true });
const scheduleMap = import.meta.glob("../data/schedules/*.json", { eager: true });
const metaMap = import.meta.glob("../data/meta/*.json", { eager: true });

const normalize = (obj) => {
  const out = {};
  for (const path in obj) {
    const key = path.split("/").pop().replace(".json", "");
    out[key] = obj[path].default;
  }
  return out;
};

const rosters = normalize(rosterMap);
const staff = normalize(staffMap);
const schedules = normalize(scheduleMap);
const meta = normalize(metaMap);

const TeamPage = () => {
  const selectedTeam = useSelector((state) => state.team.selectedTeam);
  const team = teams.find((t) => t.id === selectedTeam);

  const [tab, setTab] = useState("roster");
  const [selectedPlayer, setSelectedPlayer] = useState(null);

  const [season, setSeason] = useState(() => {
    console.log("[TeamPage] Initial season state from JSON:", seasonState);
    return seasonState;
  });

  const handlePlayerClick = (player) => setSelectedPlayer(player);

  const canAdvance = true;
  const warnings = [];

  if (season.warnings?.injuries > 0)
    warnings.push(`${season.warnings.injuries} injured starters`);
  if (season.warnings?.depthChartIssues > 0)
    warnings.push("Depth chart incomplete");
  if (season.warnings?.capOver)
    warnings.push("Over the salary cap");

  const handleAdvance = () => {
    console.log(
      "[TeamPage] Advance clicked — phase:",
      season.phase,
      "week:",
      season.week,
      "preseasonWeek:",
      season.preseasonWeek,
      "offseasonStep:",
      season.offseasonStep
    );

    setSeason((prev) => {
      const next = advanceSeason(prev, {
        teams,
        schedules,
        rosters,
        staff
      });

      console.log("[TeamPage] Season after advanceSeason:", next);
      return next;
    });
  };


  // Source of truth for schedule:
  // 1) Engine-populated league schedules (season.schedules[teamId])
  // 2) Fallback to static JSON if engine not initialized yet
  const activeSchedule =
    season.schedules?.[selectedTeam] || schedules[selectedTeam] || [];

  if (!team) {
    return <div style={{ padding: "24px" }}>Select a team to begin.</div>;
  }

  return (
    <div style={{ paddingBottom: "40px" }}>
      <TeamHeader
        team={team}
        season={season}
        meta={meta[selectedTeam]}
      />

      {/* Roadmap removed here to reduce clutter; global shell roadmap remains */}

      <NextActionCard
        season={season}
        onAdvance={handleAdvance}
        canAdvance={canAdvance}
        warnings={warnings}
      />

      <div style={{ height: "12px" }} />

      <TeamTabs tab={tab} setTab={setTab} />

      <div style={{ marginTop: "20px" }}>
        {tab === "roster" && (
          <RosterTable
            roster={rosters[selectedTeam]}
            onPlayerClick={handlePlayerClick}
          />
        )}

        {tab === "depthChart" && (
          <DepthChart
            roster={rosters[selectedTeam]}
            onPlayerClick={handlePlayerClick}
          />
        )}

        {tab === "staff" && (
          <StaffTable
            staff={staff[selectedTeam]}
            onPlayerClick={handlePlayerClick}
          />
        )}

        {tab === "finances" && (
          <FinancesPanel meta={meta[selectedTeam]} />
        )}

        {tab === "schedule" && (
          <ScheduleTab schedule={activeSchedule} />
        )}

        {tab === "Standings" && (
          <DivisionStandings
            teams={teams}
            userTeam={team}
            season={season}
          />
        )}

        {tab === "playoffs" && (
          <PlayoffsTab
            season={season}
            userTeamId={selectedTeam}
          />
        )}


        {tab === "stats" && <StatsPanel />}
      </div>

      <PlayerModal
        player={selectedPlayer}
        onClose={() => setSelectedPlayer(null)}
      />
    </div>
  );
};

export default TeamPage;





**********************


src/utils/seasonEngine.js:

// src/utils/seasonEngine.js

import { initializePlayoffs, simulatePlayoffRound } from "./playoffEngine";
import { generateSeasonSchedule } from "./scheduleGenerator";
import { simulateWeightedGame } from "./gameSim";
const DEBUG_GAME_SIM = true;   // set to false to silence logs


const PRESEASON_WEEKS = 3;
const REGULAR_SEASON_WEEKS = 18;
const PLAYOFF_ROUNDS = ["WILDCARD", "DIVISIONAL", "CONFERENCE", "SUPER_BOWL"];
const OFFSEASON_STEPS = ["RESIGNINGS", "FREE_AGENCY", "DRAFT"];

/* ======================================================
   HELPERS (COACH RATINGS)
====================================================== */

function extractCoachRatings(staffByTeam) {
  const out = {};
  if (!staffByTeam) return out;

  for (const teamId in staffByTeam) {
    const coaches = staffByTeam[teamId] || [];
    const headCoach = coaches.find((c) => c.role === "HC");
    out[teamId] = headCoach?.ratings?.overall ?? 75;
  }

  return out;
}

/* ======================================================
   PUBLIC API
====================================================== */

export function advanceSeason(prev, context) {
  const season = structuredClone(prev);

  // Initialize league once per season
  if (!season._initialized) {
    initializeLeague(season, context);
  }

  console.log(
    "[seasonEngine] advanceSeason — phase:",
    season.phase,
    "preseasonWeek:",
    season.preseasonWeek,
    "week:",
    season.week,
    "offseasonStep:",
    season.offseasonStep
  );

  switch (season.phase) {
    case "OFFSEASON":
      advanceOffseason(season);
      break;

    case "PRESEASON":
      simulatePreseasonWeek(season, context);
      break;

    case "REGULAR_SEASON":
      simulateRegularSeasonWeek(season, context);
      break;

    case "PLAYOFFS":
      advancePlayoffs(season);
      break;

    default:
      break;
  }

  return season;
}

/* ======================================================
   INITIALIZATION
====================================================== */

function initializeLeague(season, { teams }) {
  console.log("[seasonEngine] initializeLeague — starting with:", season);

  // ---- SCHEDULES ----
  console.log(`[seasonEngine] Generating procedural schedule for ${season.year}`);
  season.schedules = generateSeasonSchedule(season.year);


  season._initialized = true;

  // ---- STANDINGS ----
  season.teams = {};
  teams.forEach((t) => {
    season.teams[t.id] = {
      wins: 0,
      losses: 0,
      ties: 0,
      pointsFor: 0,
      pointsAgainst: 0
    };
  });

  season.gamesByKey = {}; // keyed by `${type}-${week}-${sortedTeamIds}`

  // ---- TIMING ----
  season.phase = "OFFSEASON";
  season.offseasonStep = OFFSEASON_STEPS[0];

  season.preseasonWeek = 1; // 1–3
  season.week = 1; // 1–18
  season.playoffRound = null;

  season.lastResult = {
    summary: "League initialized",
    details: "Offseason — RESIGNINGS"
  };

  console.log("[seasonEngine] initializeLeague — finished:", season);
}

/* ======================================================
   OFFSEASON
====================================================== */

function advanceOffseason(season) {
  const idx = OFFSEASON_STEPS.indexOf(season.offseasonStep);

  if (idx < OFFSEASON_STEPS.length - 1) {
    season.offseasonStep = OFFSEASON_STEPS[idx + 1];
    season.lastResult = {
      summary: `${OFFSEASON_STEPS[idx]} complete`,
      details: ""
    };
  } else {
    season.phase = "PRESEASON";
    season.offseasonStep = null;
    season.lastResult = {
      summary: "Offseason complete",
      details: "Preseason begins."
    };
  }
}

/* ======================================================
   PRESEASON
====================================================== */

function simulatePreseasonWeek(season, context) {
  const week = season.preseasonWeek;
  const key = `PRESEASON-${week}`;

  if (season.gamesByKey[key]) {
    console.log("[seasonEngine] Preseason week already simulated:", week);
    advanceFromPreseasonIfDone(season);
    return;
  }

  const games = simulateGamesForWeek(
    season,
    {
      week,
      type: "PRESEASON",
      affectStandings: false
    },
    context
  );

  season.gamesByKey[key] = games;

  season.lastResult = {
    summary: `Preseason Week ${week} complete`,
    details: `${games.length} games played`
  };

  if (week < PRESEASON_WEEKS) {
    season.preseasonWeek += 1;
  } else {
    season.phase = "REGULAR_SEASON";
    season.week = 1;
    season.lastResult = {
      summary: "Preseason complete",
      details: "Ready to begin Week 1."
    };
  }
}

function advanceFromPreseasonIfDone(season) {
  if (season.preseasonWeek >= PRESEASON_WEEKS) {
    season.phase = "REGULAR_SEASON";
    season.week = 1;
    season.lastResult = {
      summary: "Preseason complete",
      details: "Ready to begin Week 1."
    };
  } else {
    season.preseasonWeek += 1;
  }
}

/* ======================================================
   REGULAR SEASON
====================================================== */

function simulateRegularSeasonWeek(season, context) {
  const week = season.week;
  const key = `REGULAR_SEASON-${week}`;

  if (season.gamesByKey[key]) {
    console.log("[seasonEngine] Regular season week already simulated:", week);
    advanceFromRegularSeasonIfDone(season);
    return;
  }

  const games = simulateGamesForWeek(
    season,
    {
      week,
      type: "REGULAR_SEASON",
      affectStandings: true
    },
    context
  );

  season.gamesByKey[key] = games;

  season.lastResult = {
    summary: `Week ${week} complete`,
    details: `${games.length} games played`
  };

  if (week < REGULAR_SEASON_WEEKS) {
    season.week += 1;
  } else {
    season.phase = "PLAYOFFS";
    season.week = null;
    season.playoffRound = PLAYOFF_ROUNDS[0];
    season.lastResult = {
      summary: "Regular season complete",
      details: "Playoffs begin."
    };
  }
}

function advanceFromRegularSeasonIfDone(season) {
  if (season.week >= REGULAR_SEASON_WEEKS) {
    season.phase = "PLAYOFFS";
    season.week = null;
    season.playoffRound = PLAYOFF_ROUNDS[0];
    season.lastResult = {
      summary: "Regular season complete",
      details: "Playoffs begin."
    };
  } else {
    season.week += 1;
  }
}

/* ======================================================
   SHARED GAME SIMULATION
====================================================== */

function simulateGamesForWeek(season, { week, type, affectStandings }, context) {
  const games = [];
  const paired = new Set();

  const coachRatingsByTeam = extractCoachRatings(context?.staff);
  const rostersByTeam = context?.rosters || {};

  Object.entries(season.schedules).forEach(([teamId, schedule]) => {
    const game = schedule.find((g) => g.week === week && g.type === type);
    if (!game) return;

    // Bye week
    if (game.result === "BYE" || game.opponent === null) return;

    const opponentId = game.opponent;

    // Canonical pair key: same for both teams
    const pairKey = `${type}-${week}-${[teamId, opponentId]
      .sort()
      .join("-")}`;
    if (paired.has(pairKey)) return;
    paired.add(pairKey);

    const home = game.home ? teamId : opponentId;
    const away = game.home ? opponentId : teamId;

    const result = simulateGame(
      home,
      away,
      rostersByTeam,
      coachRatingsByTeam
    );

    games.push(result);

    if (affectStandings) {
      applyResult(season, result);
    }

    markGamesPlayed(season, week, type, result);
  });

  console.log(
    "[seasonEngine] simulateGamesForWeek",
    "type:",
    type,
    "week:",
    week,
    "games:",
    games.length
  );

  return games;
}

/* ======================================================
   PLAYOFFS
====================================================== */

function advancePlayoffs(season) {
  if (!season.playoffs?.initialized) {
    initializePlayoffs(season);
    season.playoffRound = PLAYOFF_ROUNDS[0];
    season.lastResult = {
      summary: "Playoffs begin",
      details: "Wildcard round set."
    };
    return;
  }

  const summary = simulatePlayoffRound(season);
  const idx = PLAYOFF_ROUNDS.indexOf(season.playoffRound);
  const isLast = idx === PLAYOFF_ROUNDS.length - 1;

  if (!isLast) {
    const prevRound = season.playoffRound;
    season.playoffRound = PLAYOFF_ROUNDS[idx + 1];
    season.lastResult = {
      summary: `${prevRound.replace("_", " ")} complete`,
      details: summary
    };
  } else {
    const finalSummary = summary || "Super Bowl complete.";
    season.lastResult = {
      summary: "Season complete",
      details: finalSummary
    };
    resetForNextSeason(season);
  }
}

/* ======================================================
   SEASON RESET
====================================================== */

function resetForNextSeason(season) {
  season.year += 1;

  Object.values(season.teams).forEach((t) => {
    t.wins = 0;
    t.losses = 0;
    t.ties = 0;
    t.pointsFor = 0;
    t.pointsAgainst = 0;
  });

  // We let initializeLeague rebuild schedules for the new year
  season.gamesByKey = {};
  season._initialized = false;

  season.phase = "OFFSEASON";
  season.offseasonStep = OFFSEASON_STEPS[0];
  season.preseasonWeek = 1;
  season.week = 1;
  season.playoffRound = null;

  season.lastResult = {
    summary: "Season complete",
    details: `Welcome to the ${season.year} season`
  };
}

/* ======================================================
   GAME SIMULATION
====================================================== */

function simulateGame(home, away, rostersByTeam, coachRatingsByTeam) {
  const result = simulateWeightedGame({
    homeTeamId: home,
    awayTeamId: away,
    rostersByTeam,
    coachRatingsByTeam,
    chaosStdDev: 5
  });

  if (DEBUG_GAME_SIM) {
    const homeStrength = result.homeStrength.toFixed(1);
    const awayStrength = result.awayStrength.toFixed(1);
    const diff = (result.homeStrength - result.awayStrength).toFixed(1);

    const homeQB =
      (rostersByTeam[home]?.find((p) => p.position === "QB")?.ratings?.overall ??
        0);
    const awayQB =
      (rostersByTeam[away]?.find((p) => p.position === "QB")?.ratings?.overall ??
        0);

    const qbDiff = homeQB - awayQB;

    console.log(
      `GAME SIM: ${home} (${homeStrength}) vs ${away} (${awayStrength}) → diff ${diff}`
    );
    console.log(`QB diff: ${qbDiff}`);
    console.log(
      `Winner: ${result.homeScore > result.awayScore ? home : away} (${result.homeScore}-${result.awayScore})`
    );
    console.log("--------------------------------------------------");
  }

  return {
    home,
    away,
    homeScore: result.homeScore,
    awayScore: result.awayScore
  };
}



function applyResult(season, game) {
  const { home, away, homeScore, awayScore } = game;

  const homeTeam = season.teams[home];
  const awayTeam = season.teams[away];

  homeTeam.pointsFor += homeScore;
  homeTeam.pointsAgainst += awayScore;
  awayTeam.pointsFor += awayScore;
  awayTeam.pointsAgainst += homeScore;

  if (homeScore > awayScore) {
    homeTeam.wins++;
    awayTeam.losses++;
  } else if (awayScore > homeScore) {
    awayTeam.wins++;
    homeTeam.losses++;
  } else {
    homeTeam.ties++;
    awayTeam.ties++;
  }
}

function markGamesPlayed(season, week, type, game) {
  const { home, away, homeScore, awayScore } = game;

  const update = (teamId, scored, allowed) => {
    const g = season.schedules[teamId].find(
      (x) => x.week === week && x.type === type
    );
    if (!g) return;

    g.played = true;
    g.scoreFor = scored;
    g.scoreAgainst = allowed;
    g.result = scored > allowed ? "W" : scored < allowed ? "L" : "T";
  };

  update(home, homeScore, awayScore);
  update(away, awayScore, homeScore);
}

/* ======================================================
   EXPORTED HELPERS
====================================================== */

export function getOffseasonSteps() {
  return OFFSEASON_STEPS;
}

export function getPlayoffRounds() {
  return PLAYOFF_ROUNDS;
}






****************************************

src/data/season/seasonState.json:

{
  "year": 2026,
  "phase": "OFFSEASON",
  "offseasonStep": "RESIGNINGS",
  "week": 0,
  "_initialized": false,
  "warnings": {
    "injuries": 0,
    "depthChartIssues": 0,
    "capOver": false
  },
  "lastResult": {
    "summary": "New franchise loaded",
    "details": "Offseason — RESIGNINGS"
  }
}


***********************************

schedule.json example - BAL:

 {
    "week": 1,
    "type": "PRESEASON",
    "opponent": "NO",
    "home": true,
    "played": false,
    "scoreFor": null,
    "scoreAgainst": null,
    "result": null,
    "overtime": false,
    "attendance": 76443,
    "notes": null
  },
  {
    "week": 2,
    "type": "PRESEASON",
    "opponent": "JAX",
    "home": false,
    "played": false,
    "scoreFor": null,
    "scoreAgainst": null,
    "result": null,
    "overtime": false,
    "attendance": 63618,
    "notes": null
  },
  {
    "week": 3,
    "type": "PRESEASON",
    "opponent": "NYJ",
    "home": true,
    "played": false,
    "scoreFor": null,
    "scoreAgainst": null,
    "result": null,
    "overtime": false,
    "attendance": 67968,
    "notes": null
  },
  {
    "week": 4,
    "type": "REGULAR_SEASON",
    "opponent": "DET",
    "home": false,
    "played": false,
    "scoreFor": null,
    "scoreAgainst": null,
    "result": null,
    "overtime": false,
    "attendance": 64834,
    "notes": null
  },
  {
    "week": 5,
    "type": "REGULAR_SEASON",
    "opponent": "PHI",
    "home": true,
    "played": false,
    "scoreFor": null,
    "scoreAgainst": null,
    "result": null,
    "overtime": false,
    "attendance": 62504,
    "notes": null


**************************************

src/data/teams.js:

export const teams = [
  // -------------------- AFC NORTH --------------------
  { id: "BAL", city: "BAL", mascot: "Nightwings", conference: "AFC", division: "North", color: "#5A4FCF" },
  { id: "CIN", city: "CIN", mascot: "Striped Fury", conference: "AFC", division: "North", color: "#F77F2F" },
  { id: "CLE", city: "CLE", mascot: "Forge Hounds", conference: "AFC", division: "North", color: "#A65A2E" },
  { id: "PIT", city: "PIT", mascot: "Ironhammers", conference: "AFC", division: "North", color: "#6E6E6E" },

  // -------------------- AFC EAST --------------------
  { id: "BUF", city: "BUF", mascot: "Frosthorns", conference: "AFC", division: "East", color: "#3A6FF7" },
  { id: "MIA", city: "MIA", mascot: "Neon Sharks", conference: "AFC", division: "East", color: "#00C9A7" },
  { id: "NE",  city: "NE",  mascot: "Liberty Knights", conference: "AFC", division: "East", color: "#34495E" },
  { id: "NYJ", city: "NYJ", mascot: "Green Flight", conference: "AFC", division: "East", color: "#2ECC71" },

  // -------------------- AFC SOUTH --------------------
  { id: "HOU", city: "HOU", mascot: "Red Guardians", conference: "AFC", division: "South", color: "#C0392B" },
  { id: "IND", city: "IND", mascot: "Blue Chargers", conference: "AFC", division: "South", color: "#2E86DE" },
  { id: "JAX", city: "JAX", mascot: "Jungle Strikers", conference: "AFC", division: "South", color: "#D4A017" },
  { id: "TEN", city: "TEN", mascot: "Thunder Titans", conference: "AFC", division: "South", color: "#5DADE2" },

  // -------------------- AFC WEST --------------------
  { id: "DEN", city: "DEN", mascot: "Storm Riders", conference: "AFC", division: "West", color: "#FF7F50" },
  { id: "KC",  city: "KC",  mascot: "Warforge", conference: "AFC", division: "West", color: "#D63031" },
  { id: "LV",  city: "LV",  mascot: "Black Spades", conference: "AFC", division: "West", color: "#555555" },
  { id: "LAC", city: "LAC", mascot: "Volt Surge", conference: "AFC", division: "West", color: "#4DA6FF" },

  // -------------------- NFC NORTH --------------------
  { id: "CHI", city: "CHI", mascot: "Wind Bears", conference: "NFC", division: "North", color: "#CA6F1E" },
  { id: "DET", city: "DET", mascot: "Motor Lions", conference: "NFC", division: "North", color: "#5DADE2" },
  { id: "GB",  city: "GB",  mascot: "Green Guardians", conference: "NFC", division: "North", color: "#27AE60" },
  { id: "MIN", city: "MIN", mascot: "Storm Vikings", conference: "NFC", division: "North", color: "#8E44AD" },

  // -------------------- NFC EAST --------------------
  { id: "DAL", city: "DAL", mascot: "Lone Stars", conference: "NFC", division: "East", color: "#2C3E50" },
  { id: "NYG", city: "NYG", mascot: "Empire Giants", conference: "NFC", division: "East", color: "#3A6FF7" },
  { id: "PHI", city: "PHI", mascot: "Sky Eagles", conference: "NFC", division: "East", color: "#1ABC9C" },
  { id: "WAS", city: "WAS", mascot: "Capital Command", conference: "NFC", division: "East", color: "#884EA0" },

  // -------------------- NFC SOUTH --------------------
  { id: "ATL", city: "ATL", mascot: "Firebirds", conference: "NFC", division: "South", color: "#E74C3C" },
  { id: "CAR", city: "CAR", mascot: "Panther Claw", conference: "NFC", division: "South", color: "#2980B9" },
  { id: "NO",  city: "NO",  mascot: "Golden Saints", conference: "NFC", division: "South", color: "#D4AC0D" },
  { id: "TB",  city: "TB",  mascot: "Bay Pirates", conference: "NFC", division: "South", color: "#C0392B" },

  // -------------------- NFC WEST --------------------
  { id: "ARI", city: "ARI", mascot: "Red Talons", conference: "NFC", division: "West", color: "#C0392B" },
  { id: "LAR", city: "LAR", mascot: "Royal Rams", conference: "NFC", division: "West", color: "#F1C40F" },
  { id: "SF",  city: "SF",  mascot: "Gold Rush", conference: "NFC", division: "West", color: "#D68910" },
  { id: "SEA", city: "SEA", mascot: "Stormhawks", conference: "NFC", division: "West", color: "#2ECC71" }
];


*************************

src/data/rosters - team.json example -- BAL:

"id": "BAL-QB-1",
    "team": "BAL",
    "teamName": "BAL",
    "name": "Shawn Predovic",
    "jerseyNumber": 93,
    "position": "QB",
    "side": "OFF",
    "depth": 1,
    "vitals": {
      "age": 21,
      "height": "5'11\"",
      "weight": 212,
      "college": "Odessaview",
      "experience": 1,
      "archetype": "Power",
      "handedness": "Right"
    },
    "contract": {
      "years": 2,
      "totalValue": 89963480,
      "capHit": 3452495,
      "deadCap": 9039754,
      "signingBonus": 12320653,
      "expiresYear": 2028,
      "contractType": "Standard"
    },
    "ratings": {
      "overall": 79,
      "potential": 83,
      "schemeFit": 89,
      "speed": 71,
      "acceleration": 91,
      "agility": 94,
      "strength": 93,
      "tackle": 74,
      "pursuit": 72,
      "manCoverage": 62,
      "zoneCoverage": 78,
      "kickPower": 90,
      "kickAccuracy": 64,
      "catching": 94,
      "routeRunning": 90,
      "release": 83,
      "throwPower": 90,
      "shortAccuracy": 80,
      "mediumAccuracy": 94,
      "deepAccuracy": 86
    },
    "traits": {
      "personality": "Calm",
      "devTrait": "Superstar",
      "clutch": "High",
      "injuryProne": "Medium",
      "workEthic": "Low",
      "leadership": "High"
    },
    "stats": {
      "season": {
        "games": 6,
        "statA": 102,
        "statB": 313
      },
      "career": {
        "games": 104,
        "statA": 3505,
        "statB": 2111
      }
    },
    "photo": "/player_faces/43.png"
  },


***************************************

src/components/season/NextActionCard.jsx:

import React from "react";
import styles from "./NextActionCard.module.css";

export default function NextActionCard({
  season,
  onAdvance,
  canAdvance = true,
  warnings = []
}) {
  if (!season) return null;

  const { title, subtitle, actionLabel } = getActionConfig(season);

  return (
    <div className={styles.container}>
      {/* LEFT COLUMN */}
      <div className={styles.leftCol}>
        <div className={styles.title}>{title}</div>
        <div className={styles.subtitle}>{subtitle}</div>

        {warnings.length > 0 && (
          <div className={styles.warningBlock}>
            <div className={styles.warningHeader}>Warnings</div>
            <ul className={styles.warningList}>
              {warnings.map((w, i) => (
                <li key={i}>{w}</li>
              ))}
            </ul>
          </div>
        )}
      </div>

      {/* MIDDLE COLUMN */}
      <div className={styles.middleCol}>
        <button
          className={`${styles.button} ${!canAdvance ? styles.disabled : ""}`}
          disabled={!canAdvance}
          onClick={() => canAdvance && onAdvance?.(season)}
        >
          {actionLabel}
        </button>
      </div>

      {/* RIGHT COLUMN */}
      <div className={styles.rightCol}>
        <div className={styles.resultBlock}>
          {season.lastResult?.summary && (
            <div className={styles.resultSummary}>
              {season.lastResult.summary}
            </div>
          )}
          {season.lastResult?.details && (
            <div className={styles.resultDetails}>
              {season.lastResult.details}
            </div>
          )}
        </div>
      </div>
    </div>
  );
}

function getActionConfig(season) {
  switch (season.phase) {
    case "PRESEASON":
      return {
        title: `Preseason — Week ${season.preseasonWeek}`,
        subtitle: `Preseason Week ${season.preseasonWeek}`,
        actionLabel: `Sim Preseason Week ${season.preseasonWeek}`
      };

    case "REGULAR_SEASON": {
      const prevWeekKey = `REGULAR_SEASON-${season.week - 1}`;
      const hasPrevWeek = season.gamesByKey?.[prevWeekKey];

      return {
        title: `Regular Season — Week ${season.week}`,
        subtitle: hasPrevWeek
          ? `Week ${season.week - 1} Complete`
          : `Ready to begin Week ${season.week}`,
        actionLabel: `Sim Week ${season.week}`
      };
    }

    case "PLAYOFFS":
      return {
        title: `Playoffs — ${season.playoffRound}`,
        subtitle: "Win or go home",
        actionLabel: "Sim Next Round"
      };

    case "OFFSEASON":
      return {
        title: `Offseason — ${season.offseasonStep}`,
        subtitle: "Team building phase",
        actionLabel: "Advance"
      };

    default:
      return {
        title: "Season",
        subtitle: "",
        actionLabel: "Advance"
      };
  }
}





**************************************

NextActionCard.module.css:

.container {
  display: grid;
  grid-template-columns: 1fr auto 1fr;
  align-items: center;
  gap: 20px;

  background: linear-gradient(
    145deg,
    rgba(0, 212, 255, 0.12),
    rgba(0, 212, 255, 0.04)
  );
  border: 1px solid rgba(0, 212, 255, 0.35);
  border-radius: 14px;
  padding: 16px 20px;
  box-shadow: var(--shadow);
  margin-bottom: 20px;
}

/* LEFT COLUMN */
.leftCol {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.title {
  font-size: 1rem;
  font-weight: 700;
}

.subtitle {
  font-size: 0.85rem;
  color: var(--color-text-muted);
}

/* WARNINGS BLOCK */
.warningBlock {
  margin-top: 6px;
}

.warningHeader {
  font-size: 0.75rem;
  color: var(--color-text-muted);
  margin-bottom: 2px;
}

.warningList {
  margin: 0;
  padding-left: 16px;
  color: #ff4444;
  font-size: 0.8rem;
  font-weight: 600;
}

/* MIDDLE COLUMN */
.middleCol {
  display: flex;
  justify-content: center;
}

.button {
  background: #3e4147;
  color: white;
  border: none;
  border-radius: 10px;
  padding: 10px 20px;
  font-weight: 700;
  cursor: pointer;
  box-shadow: 0 6px 14px rgba(11, 94, 215, 0.35);
}

.button:hover {
  transform: translateY(-1px);
  filter: brightness(1.05);
}

.disabled {
  opacity: 0.4;
  cursor: not-allowed;
  box-shadow: none;
}

/* RIGHT COLUMN */
.rightCol {
  display: flex;
  justify-content: flex-end;
}

.resultBlock {
  text-align: right;
}

.resultSummary {
  font-size: 0.85rem;
  font-weight: 700;
}

.resultDetails {
  font-size: 0.75rem;
  color: var(--color-text-muted);
}

/* MOBILE */
@media (max-width: 768px) {
  .container {
    grid-template-columns: 1fr;
    text-align: left;
  }

  .rightCol {
    justify-content: flex-start;
  }

  .resultBlock {
    text-align: left;
  }
}


****************************************

src/components/season/TeamSeasonRoadmap.jsx:

import React from "react";
import styles from "./TeamSeasonRoadmap.module.css";
import { getOffseasonSteps, getPlayoffRounds } from "../../utils/seasonEngine";

const PHASES = [
  { key: "PRESEASON", label: "Preseason" },
  { key: "REGULAR_SEASON", label: "Regular Season" },
  { key: "PLAYOFFS", label: "Playoffs" },
  { key: "OFFSEASON", label: "Offseason" },
];

export default function TeamSeasonRoadmap({ season, onSelectPhase }) {
  if (!season) return null;

  const currentIndex = PHASES.findIndex((p) => p.key === season.phase);
  const offseasonSteps = getOffseasonSteps();
  const playoffRounds = getPlayoffRounds();

  return (
    <div className={styles.container}>
      <div className={styles.title}>Season Progress</div>

      <div className={styles.phases}>
        {PHASES.map((phase, index) => {
          const isCompleted = index < currentIndex;
          const isActive = index === currentIndex;

          return (
            <div
              key={phase.key}
              className={`${styles.phase}
                ${isCompleted ? styles.completed : ""}
                ${isActive ? styles.active : ""}
                ${onSelectPhase ? styles.clickable : ""}
              `}
              onClick={() => onSelectPhase?.(phase.key)}
            >
              <div className={styles.phaseHeader}>
                <span>{phase.label}</span>

                {isActive &&
                  phase.key === "REGULAR_SEASON" &&
                  season.week && (
                    <span className={styles.subtle}>Week {season.week}</span>
                  )}

                {isActive &&
                  phase.key === "PLAYOFFS" &&
                  season.playoffRound && (
                    <span className={styles.subtle}>
                      {season.playoffRound.replace("_", " ")}
                    </span>
                  )}

                {isActive &&
                  phase.key === "OFFSEASON" &&
                  season.offseasonStep && (
                    <span className={styles.subtle}>
                      {season.offseasonStep.replace("_", " ")}
                    </span>
                  )}
              </div>

              {isActive && phase.key === "OFFSEASON" && (
                <div className={styles.subSteps}>
                  {offseasonSteps.map((step) => {
                    const isStepActive = step === season.offseasonStep;
                    return (
                      <div
                        key={step}
                        className={`${styles.subStep} ${
                          isStepActive ? styles.subStepActive : ""
                        }`}
                      >
                        {step.replace("_", " ")}
                      </div>
                    );
                  })}
                </div>
              )}

              {isActive && phase.key === "PLAYOFFS" && (
                <div className={styles.subSteps}>
                  {playoffRounds.map((round) => {
                    const isRoundActive = round === season.playoffRound;
                    return (
                      <div
                        key={round}
                        className={`${styles.subStep} ${
                          isRoundActive ? styles.subStepActive : ""
                        }`}
                      >
                        {round.replace("_", " ")}
                      </div>
                    );
                  })}
                </div>
              )}
            </div>
          );
        })}
      </div>
    </div>
  );
}


*********************************************

src/components/team/schedule/ScheduleTab.jsx

import React from "react";
import { teams } from "../../../data/teams";
import styles from "./ScheduleTab.module.css";

function getOpponentLabel(game) {
  if (game.result === "BYE" || game.opponent === null) return "BYE WEEK";

  const oppTeam = teams.find((t) => t.id === game.opponent);
  const oppName = oppTeam ? `${oppTeam.city} ${oppTeam.mascot}` : game.opponent;
  const prefix = game.home ? "vs" : "@";

  return `${prefix} ${oppName}`;
}

function getScoreLabel(game) {
  if (game.result === "BYE" || game.opponent === null) return "-";
  if (!game.played) return "—";
  return `${game.scoreFor} - ${game.scoreAgainst}`;
}

function getResultClass(result, styles) {
  if (result === "W") return styles.resultWin;
  if (result === "L") return styles.resultLoss;
  if (result === "T") return styles.resultTie;
  if (result === "BYE") return styles.resultBye;
  return styles.resultNeutral;
}

export default function ScheduleTab({ schedule }) {
  if (!schedule || schedule.length === 0) {
    return <div>No schedule available.</div>;
  }

  const regularSeasonGames = schedule
    .filter((g) => g.type === "REGULAR_SEASON")
    .sort((a, b) => a.week - b.week);

  return (
    <div className={styles.container}>
      <div className={styles.headerRow}>
        <div>Week</div>
        <div>Matchup</div>
        <div className={styles.center}>Score</div>
        <div className={styles.center}>Result</div>
      </div>

      {regularSeasonGames.map((game, idx) => (
        <div
          key={`${game.week}-${game.opponent ?? "BYE"}-${idx}`}
          className={styles.row}
        >
          <div>Week {game.week}</div>
          <div>{getOpponentLabel(game)}</div>
          <div className={`${styles.center} ${styles.score}`}>
            {getScoreLabel(game)}
          </div>
          <div
            className={`${styles.center} ${getResultClass(
              game.result,
              styles
            )}`}
          >
            {game.result === "BYE" ? "BYE" : game.result || ""}
          </div>
        </div>
      ))}
    </div>
  );
}


*********************************************

ScheduleTab.module.css:

.container {
  padding: 20px;
  background-color: #0f111a;
  border-radius: 12px;
  display: flex;
  flex-direction: column;
  gap: 12px;
  color: #fff;
}

.headerRow {
  display: grid;
  grid-template-columns: 80px 1fr 80px 70px;
  padding-bottom: 8px;
  border-bottom: 2px solid #00d4ff;
  font-weight: 700;
  color: #00d4ff;
}

.row {
  display: grid;
  grid-template-columns: 80px 1fr 80px 70px;
  padding: 10px 0;
  border-bottom: 1px solid rgba(255, 255, 255, 0.08);
  transition: background 0.2s ease;
}

.row:hover {
  background: rgba(0, 212, 255, 0.08);
}

.center {
  text-align: center;
}

.score {
  font-weight: 700;
}

.resultWin {
  color: #2ecc71;
  font-weight: 700;
}

.resultLoss {
  color: #e74c3c;
  font-weight: 700;
}

.resultTie {
  color: #f1c40f;
  font-weight: 700;
}

.resultBye {
  color: #a0a0a0;
  font-weight: 600;
}

.resultNeutral {
  color: #a0a0a0;
}




*****************************************

src/components/standings/DivisionStandings.jsx:

import React from "react";
import styles from "./DivisionStandings.module.css";

function getRecord(season, teamId) {
  return season.teams?.[teamId] || {
    wins: 0,
    losses: 0,
    ties: 0,
    pointsFor: 0,
    pointsAgainst: 0
  };
}

function sortDivisionTeams(season, teamsInDivision) {
  return [...teamsInDivision].sort((a, b) => {
    const ra = getRecord(season, a.id);
    const rb = getRecord(season, b.id);

    if (rb.wins !== ra.wins) return rb.wins - ra.wins;
    if (rb.ties !== ra.ties) return rb.ties - ra.ties;

    const diffA = ra.pointsFor - ra.pointsAgainst;
    const diffB = rb.pointsFor - rb.pointsAgainst;

    return diffB - diffA;
  });
}

function renderConferenceColumn(conferenceName, teams, season, userTeam) {
  const divisions = ["North", "East", "South", "West"];

  return (
    <div className={styles.conferenceColumn}>
      <div className={styles.conferenceTitle}>{conferenceName}</div>

      {divisions.map((division) => {
        const divisionTeams = teams.filter(
          (t) => t.conference === conferenceName && t.division === division
        );

        if (divisionTeams.length === 0) return null;

        const sorted = sortDivisionTeams(season, divisionTeams);

        return (
          <div key={division} className={styles.divisionBlock}>
            <div className={styles.divisionTitle}>{division}</div>

            <div className={styles.headerRow}>
              <div>Team</div>
              <div className={styles.center}>W</div>
              <div className={styles.center}>L</div>
              <div className={styles.center}>T</div>
            </div>

            {sorted.map((team) => {
              const rec = getRecord(season, team.id);
              const highlight = userTeam && userTeam.id === team.id;

              return (
                <div
                  key={team.id}
                  className={`${styles.row} ${
                    highlight ? styles.rowHighlight : ""
                  }`}
                >
                  <div>{team.city} {team.mascot}</div>
                  <div className={styles.center}>{rec.wins}</div>
                  <div className={styles.center}>{rec.losses}</div>
                  <div className={styles.center}>{rec.ties}</div>
                </div>
              );
            })}
          </div>
        );
      })}
    </div>
  );
}

export default function DivisionStandings({ teams, userTeam, season }) {
  if (!season || !season.teams) {
    return <div>Standings unavailable.</div>;
  }

  return (
    <div className={styles.container}>
      {renderConferenceColumn("AFC", teams, season, userTeam)}
      {renderConferenceColumn("NFC", teams, season, userTeam)}
    </div>
  );
}




*************************************

DivisionStandings.module.css:

.container {
  display: flex;
  gap: 24px;
  align-items: flex-start;
  color: #fff;
}

.conferenceColumn {
  flex: 1;
  background-color: #0f111a;
  padding: 20px;
  border-radius: 12px;
  box-shadow: var(--shadow);
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.conferenceTitle {
  font-size: 1.1rem;
  font-weight: 700;
  color: #00d4ff;
  border-bottom: 2px solid #00d4ff;
  padding-bottom: 4px;
}

.divisionBlock {
  background: #141625;
  padding: 12px;
  border-radius: 10px;
}

.divisionTitle {
  font-size: 0.9rem;
  font-weight: 600;
  color: #00d4ff;
  margin-bottom: 6px;
}

.headerRow {
  display: grid;
  grid-template-columns: 1.6fr 0.6fr 0.6fr 0.6fr;
  padding-bottom: 6px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.15);
  color: #a0a0a0;
  font-weight: 600;
}

.row {
  display: grid;
  grid-template-columns: 1.6fr 0.6fr 0.6fr 0.6fr;
  padding: 8px 0;
  border-bottom: 1px solid rgba(255, 255, 255, 0.08);
  transition: background 0.2s ease;
}

.row:hover {
  background: rgba(0, 212, 255, 0.08);
}

.rowHighlight {
  background: rgba(0, 212, 255, 0.15);
}

.center {
  text-align: center;
}

@media (max-width: 768px) {
  .container {
    flex-direction: column;
  }
}

*****************************************

src/components/team/RosterTable.jsx:


import React from "react";
import RosterList from "./roster/RosterList";

const RosterTable = ({ roster, onPlayerClick }) => {
  return (
    <div style={{ marginTop: "16px" }}>
      <RosterList roster={roster} onPlayerClick={onPlayerClick} />
    </div>
  );
};

export default RosterTable;


**************************************

src/components/team/roster/RosterList.jsx:

import React from "react";
import styles from "./RosterList.module.css";

const RosterList = ({ roster, onPlayerClick }) => {
  if (!roster) return null;

  const groups = {};
  roster.forEach((p) => {
    if (!groups[p.position]) groups[p.position] = [];
    groups[p.position].push(p);
  });

  return (
    <div className={styles.container}>
      <div className={styles.header}>
        <div className={styles.position}>Pos</div>
        <div className={styles.name}>Name</div>
        <div className={styles.ovr}>OVR</div>
        <div className={styles.age}>Age</div>
      </div>

      {Object.keys(groups).map((pos) => {
        const groupClass = styles[`groupLabel_${pos}`] || styles.groupLabel;

        // Sort players by OVR descending
        const sortedPlayers = [...groups[pos]].sort(
          (a, b) => (b.ratings?.overall ?? 0) - (a.ratings?.overall ?? 0)
        );

        return (
          <div key={pos}>
            <div className={`${styles.groupLabel} ${groupClass}`}>
              {pos}
            </div>

            {sortedPlayers.map((player, idx) => {
              const ovr = player.ratings?.overall ?? "-";
              const ovrClass =
                ovr >= 90 ? styles.ovrElite :
                ovr >= 80 ? styles.ovrGreat :
                ovr >= 70 ? styles.ovrGood :
                styles.ovrLow;

              return (
                <div
                  key={idx}
                  className={styles.row}
                  onClick={() => onPlayerClick?.(player)}
                >
                  <div className={styles.position}>{player.position}</div>
                  <div className={styles.name}>{player.name}</div>
                  <div className={`${styles.ovr} ${ovrClass}`}>{ovr}</div>
                  <div className={styles.age}>{player.vitals?.age ?? "-"}</div>
                </div>
              );
            })}
          </div>
        );
      })}
    </div>
  );
};

export default RosterList;


******************************************

src/components/team/financesPanel.jsx (if we are tweaking finances tab i would prefer to scaffold similar to the other updated tabs (scr/components/team/finances: FinancesTab and FinancesTab.module.css

Same thing for stats...setup the same way



src/components/team/TeamHeader.jsx:

import React from "react";
import styles from "./TeamHeader.module.css";

const TeamHeader = ({ team, season, meta }) => {
  if (!team || !season) return null;

  const record = season.teams?.[team.id] || {
    wins: 0,
    losses: 0,
    ties: 0
  };

  const year = season.year ?? 2026;

  console.log("[TeamHeader] meta for team:", team.id, meta);

  const logoSrc = meta?.logo || meta?.logoUrl || null;
  const capSpace = meta?.capSpace ?? meta?.capRoom ?? null;

  return (
    <div className={styles.container}>
      {/* LEFT: LOGO + NAME */}
      <div className={styles.left}>
        <div className={styles.logoWrapper}>
          {logoSrc ? (
            <img
              src={logoSrc}
              alt={`${team.city} ${team.mascot}`}
              className={styles.logo}
            />
          ) : (
            <div
              className={styles.logoFallback}
              style={{ backgroundColor: team.color }}
            >
              {team.id}
            </div>
          )}
        </div>
        <div className={styles.teamInfo}>
          <div className={styles.teamName}>
            {team.city} {team.mascot}
          </div>
          <div className={styles.subline}>
            {team.conference} • {team.division}
          </div>
        </div>
      </div>

      {/* MIDDLE: RECORD + YEAR */}
      <div className={styles.middle}>
        <div className={styles.record}>
          {record.wins}-{record.losses}
          {record.ties ? `-${record.ties}` : ""}
        </div>
        <div className={styles.year}>Year {year}</div>
      </div>

      {/* RIGHT: CAP INFO */}
      <div className={styles.right}>
        {capSpace !== null && (
          <div className={styles.capBlock}>
            <div className={styles.capLabel}>Cap Space</div>
            <div className={styles.capValue}>
              ${Number(capSpace).toLocaleString()}
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

export default TeamHeader;

********************************************8

src/components/team/TeamHeader.module.css:

.container {
  display: flex;
  justify-content: space-between;
  align-items: center;
  background: linear-gradient(
    145deg,
    rgba(0, 212, 255, 0.12),
    rgba(0, 212, 255, 0.04)
  );
  border: 1px solid rgba(0, 212, 255, 0.35);
  border-radius: 14px;
  padding: 16px 20px;
  box-shadow: var(--shadow);
  margin-bottom: 20px;
}

/* LEFT SIDE — LOGO + TEAM NAME */
.left {
  display: flex;
  align-items: center;
  gap: 14px;
}

.logoWrapper {
  width: 64px;
  height: 64px;
  border-radius: 12px;
  overflow: hidden;
  display: flex;
  justify-content: center;
  align-items: center;
  background: #222;
}

.logo {
  width: 100%;
  height: 100%;
  object-fit: contain;
}

.logoFallback {
  width: 100%;
  height: 100%;
  color: white;
  font-weight: 700;
  font-size: 1.2rem;
  display: flex;
  justify-content: center;
  align-items: center;
}

.teamInfo {
  display: flex;
  flex-direction: column;
}

.teamName {
  font-size: 1.2rem;
  font-weight: 700;
}

.subline {
  font-size: 0.85rem;
  color: var(--color-text-muted);
}

/* MIDDLE — RECORD + YEAR */
.middle {
  text-align: center;
}

.record {
  font-size: 1.4rem;
  font-weight: 700;
}

.year {
  font-size: 0.85rem;
  color: var(--color-text-muted);
}

/* RIGHT — CAP SPACE */
.right {
  text-align: right;
}

.capBlock {
  display: flex;
  flex-direction: column;
  align-items: flex-end;
}

.capLabel {
  font-size: 0.75rem;
  color: var(--color-text-muted);
}

.capValue {
  font-size: 1rem;
  font-weight: 700;
}

/* MOBILE */
@media (max-width: 768px) {
  .container {
    flex-direction: column;
    gap: 12px;
    text-align: center;
  }

  .right {
    text-align: center;
  }

  .capBlock {
    align-items: center;
  }
}


**************************************

scripts/generateAllTeamSchedules.js:
/* eslint-env node */

// scripts/generateAllTeamSchedules.js
import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";
import { faker } from "@faker-js/faker";
import { teams } from "../src/data/teams.js";

// Fix __dirname in ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Output directory
const OUTPUT_DIR = path.join(__dirname, "../src/data/schedules");
if (!fs.existsSync(OUTPUT_DIR)) {
  fs.mkdirSync(OUTPUT_DIR, { recursive: true });
}

const TEAM_IDS = teams.map((t) => t.id);

function shuffle(array) {
  const arr = [...array];
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

function createGame({ week, opponent, home, type }) {
  return {
    week,
    type,
    opponent,
    home,
    played: false,
    scoreFor: null,
    scoreAgainst: null,
    result: null,
    overtime: false,
    attendance:
      type === "REGULAR_SEASON"
        ? faker.number.int({ min: 55000, max: 78000 })
        : faker.number.int({ min: 45000, max: 70000 }),
    notes: null
  };
}

function groupTeams() {
  const byConfDiv = {};
  teams.forEach((t) => {
    if (!byConfDiv[t.conference]) byConfDiv[t.conference] = {};
    if (!byConfDiv[t.conference][t.division])
      byConfDiv[t.conference][t.division] = [];
    byConfDiv[t.conference][t.division].push(t.id);
  });

  Object.values(byConfDiv).forEach((divs) => {
    Object.keys(divs).forEach((d) => {
      divs[d] = divs[d].slice().sort();
    });
  });

  return byConfDiv;
}

/* -----------------------------
   STRUCTURED WEEK GENERATION
------------------------------*/

function buildStructuredWeeks() {
  const byConfDiv = groupTeams();
  const weeks = [];

  const conferences = ["AFC", "NFC"];
  const divisions = ["North", "East", "South", "West"];

  // 1️⃣ Division double round robin (6 weeks)
  for (let round = 0; round < 6; round++) {
    weeks.push([]);
  }

  conferences.forEach((conf) => {
    divisions.forEach((div) => {
      const [a, b, c, d] = byConfDiv[conf][div];

      const firstHalf = [
        [[a, b], [c, d]],
        [[a, c], [b, d]],
        [[a, d], [b, c]]
      ];

      const secondHalf = firstHalf.map((games) =>
        games.map(([home, away]) => [away, home])
      );

      [...firstHalf, ...secondHalf].forEach((games, i) => {
        games.forEach(([home, away]) => {
          weeks[i].push({ home, away });
        });
      });
    });
  });

  // 2️⃣ Intra-conference paired divisions (4 weeks)
  const intraPairs = [
    { conf: "AFC", a: "North", b: "East" },
    { conf: "AFC", a: "South", b: "West" },
    { conf: "NFC", a: "North", b: "East" },
    { conf: "NFC", a: "South", b: "West" }
  ];

  for (let i = 0; i < 4; i++) weeks.push([]);

  intraPairs.forEach(({ conf, a, b }) => {
    const A = byConfDiv[conf][a];
    const B = byConfDiv[conf][b];

    for (let weekOffset = 0; weekOffset < 4; weekOffset++) {
      for (let j = 0; j < 4; j++) {
        const home = (weekOffset + j) % 2 === 0 ? A[j] : B[(j + weekOffset) % 4];
        const away = home === A[j] ? B[(j + weekOffset) % 4] : A[j];
        weeks[6 + weekOffset].push({ home, away });
      }
    }
  });

  // 3️⃣ Cross-conference paired divisions (4 weeks)
  const crossPairs = [
    { afc: "North", nfc: "North" },
    { afc: "East", nfc: "East" },
    { afc: "South", nfc: "South" },
    { afc: "West", nfc: "West" }
  ];

  for (let i = 0; i < 4; i++) weeks.push([]);

  crossPairs.forEach(({ afc, nfc }) => {
    const A = byConfDiv["AFC"][afc];
    const B = byConfDiv["NFC"][nfc];

    for (let weekOffset = 0; weekOffset < 4; weekOffset++) {
      for (let j = 0; j < 4; j++) {
        const home = (weekOffset + j) % 2 === 0 ? A[j] : B[(j + weekOffset) % 4];
        const away = home === A[j] ? B[(j + weekOffset) % 4] : A[j];
        weeks[10 + weekOffset].push({ home, away });
      }
    }
  });

  // 4️⃣ Extra 3 structured conference rotation weeks
  for (let i = 0; i < 3; i++) weeks.push([]);

  conferences.forEach((conf) => {
    const north = byConfDiv[conf]["North"];
    const south = byConfDiv[conf]["South"];
    const east = byConfDiv[conf]["East"];
    const west = byConfDiv[conf]["West"];

    for (let round = 0; round < 3; round++) {
      for (let i = 0; i < 4; i++) {
        const home1 = round % 2 === 0 ? north[i] : south[(i + round) % 4];
        const away1 = home1 === north[i] ? south[(i + round) % 4] : north[i];

        const home2 = round % 2 === 0 ? east[i] : west[(i + round) % 4];
        const away2 = home2 === east[i] ? west[(i + round) % 4] : east[i];

        weeks[14 + round].push({ home: home1, away: away1 });
        weeks[14 + round].push({ home: home2, away: away2 });
      }
    }
  });

  // 5️⃣ Add a full Week 18 with random valid matchups (Option A1)
  const extraWeek = [];
  const shuffledTeams = shuffle(TEAM_IDS.slice()); // 32 teams
  for (let i = 0; i < shuffledTeams.length; i += 2) {
    const t1 = shuffledTeams[i];
    const t2 = shuffledTeams[i + 1];
    const homeFirst = Math.random() < 0.5;
    const home = homeFirst ? t1 : t2;
    const away = homeFirst ? t2 : t1;
    extraWeek.push({ home, away });
  }
  weeks.push(extraWeek); // now 18 weeks total

  return weeks; // 18 fully valid weeks
}

/* -----------------------------
   BYE WEEK ASSIGNMENT
------------------------------*/

function assignByeWeeks() {
  const byeWeeks = {}; // teamId → week
  const allowedWeeks = Array.from({ length: 11 }, (_, i) => i + 4); // 4–14
  const weekLoad = {}; // week → number of teams on bye

  allowedWeeks.forEach((w) => (weekLoad[w] = 0));

  const shuffledTeams = shuffle(TEAM_IDS);

  shuffledTeams.forEach((teamId) => {
    const possibleWeeks = shuffle(allowedWeeks);

    for (const w of possibleWeeks) {
      if (weekLoad[w] < 4) {
        byeWeeks[teamId] = w;
        weekLoad[w]++;
        break;
      }
    }
  });

  return byeWeeks;
}

/* -----------------------------
   BUILD TEAM WEEK MAP
------------------------------*/

function assignWeeks() {
  const structuredWeeks = buildStructuredWeeks(); // 18 weeks
  const shuffledWeeks = shuffle(structuredWeeks);

  const teamWeeks = {};
  TEAM_IDS.forEach((id) => (teamWeeks[id] = {}));

  // Fill 18 real weeks with games
  shuffledWeeks.forEach((games, index) => {
    const weekNumber = index + 1; // 1–18
    games.forEach(({ home, away }) => {
      teamWeeks[home][weekNumber] = { home, away };
      teamWeeks[away][weekNumber] = { home, away };
    });
  });

  // Assign byes across weeks 4–14 (exactly one per team)
  const byeWeeks = assignByeWeeks();

  TEAM_IDS.forEach((teamId) => {
    const byeWeek = byeWeeks[teamId];
    // Remove that week's game for this team → creates a bye
    delete teamWeeks[teamId][byeWeek];
  });

  return teamWeeks;
}

/* -----------------------------
   BUILD SCHEDULE FILES
------------------------------*/

function buildSchedules() {
  const teamWeeks = assignWeeks();
  const schedules = {};

  TEAM_IDS.forEach((teamId) => {
    const schedule = [];

    // Preseason
    const others = TEAM_IDS.filter((t) => t !== teamId);
    const preOpp = shuffle(others).slice(0, 3);

    preOpp.forEach((opp, i) => {
      schedule.push(
        createGame({
          week: i + 1,
          opponent: opp,
          home: i % 2 === 0,
          type: "PRESEASON"
        })
      );
    });

    // Regular season (weeks 1–18)
    for (let week = 1; week <= 18; week++) {
      const m = teamWeeks[teamId][week];

      if (!m) {
        schedule.push({
          week,
          type: "REGULAR_SEASON",
          opponent: null,
          home: false,
          played: false,
          scoreFor: null,
          scoreAgainst: null,
          result: "BYE",
          overtime: false,
          attendance: null,
          notes: "Bye week"
        });
      } else {
        const isHome = m.home === teamId;
        const opp = isHome ? m.away : m.home;

        schedule.push(
          createGame({
            week,
            opponent: opp,
            home: isHome,
            type: "REGULAR_SEASON"
          })
        );
      }
    }

    schedules[teamId] = schedule;
  });

  return schedules;
}

function generateAllSchedules() {
  console.log("[schedule-generator] Generating schedules...");
  const schedules = buildSchedules();

  TEAM_IDS.forEach((id) => {
    const file = path.join(OUTPUT_DIR, `${id}.json`);
    fs.writeFileSync(file, JSON.stringify(schedules[id], null, 2));
    console.log(`✓ Created schedule for ${id}`);
  });

  console.log("All schedules generated successfully.");
}

generateAllSchedules();


*********************************

src/utils/playoffEngine.js:

// src/utils/playoffEngine.js
import { teams } from "../data/teams";

// ---------- helpers ----------

function sortStandings(a, b) {
  if (b.wins !== a.wins) return b.wins - a.wins;
  const diffA = a.pointsFor - a.pointsAgainst;
  const diffB = b.pointsFor - b.pointsAgainst;
  return diffB - diffA;
}

function rand(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

function simulateGame(home, away) {
  const homeScore = rand(17, 38);
  const awayScore = rand(14, 34);
  return { home, away, homeScore, awayScore };
}

function getConference(teamId) {
  const t = teams.find((x) => x.id === teamId);
  return t?.conference || null;
}

// ---------- initialization ----------

export function initializePlayoffs(season) {
  const standings = Object.entries(season.teams).map(([id, rec]) => ({
    id,
    ...rec
  }));

  const byConf = { AFC: [], NFC: [] };
  standings.forEach((t) => {
    const meta = teams.find((x) => x.id === t.id);
    if (!meta) return;
    byConf[meta.conference].push(t);
  });

  byConf.AFC.sort(sortStandings);
  byConf.NFC.sort(sortStandings);

  const seedsAFC = byConf.AFC.slice(0, 7).map((t, i) => ({
    id: t.id,
    seed: i + 1
  }));
  const seedsNFC = byConf.NFC.slice(0, 7).map((t, i) => ({
    id: t.id,
    seed: i + 1
  }));

  season.playoffs = {
    initialized: true,
    seedsByConference: {
      AFC: seedsAFC,
      NFC: seedsNFC
    },
    bracket: {
      WILDCARD: {
        AFC: buildWildcardRound(seedsAFC, "AFC"),
        NFC: buildWildcardRound(seedsNFC, "NFC")
      },
      DIVISIONAL: {
        AFC: [],
        NFC: []
      },
      CONFERENCE: {
        AFC: [],
        NFC: []
      },
      SUPER_BOWL: {
        GAME: null
      }
    }
  };
}

function buildWildcardRound(seeds, conf) {
  // seeds[0] is #1 (bye)
  const s2 = seeds[1];
  const s3 = seeds[2];
  const s4 = seeds[3];
  const s5 = seeds[4];
  const s6 = seeds[5];
  const s7 = seeds[6];

  const makeGame = (high, low, idx) => ({
    id: `${conf}-WC-${idx}`,
    round: "WILDCARD",
    conference: conf,
    home: high.id,
    away: low.id,
    homeSeed: high.seed,
    awaySeed: low.seed,
    played: false,
    homeScore: null,
    awayScore: null,
    winner: null
  });

  return [
    makeGame(s2, s7, 1),
    makeGame(s3, s6, 2),
    makeGame(s4, s5, 3)
  ];
}

// ---------- round simulation ----------

export function simulatePlayoffRound(season) {
  const round = season.playoffRound;
  const { bracket, seedsByConference } = season.playoffs;

  if (round === "WILDCARD") {
    const results = [];

    ["AFC", "NFC"].forEach((conf) => {
      const games = bracket.WILDCARD[conf];
      games.forEach((g) => {
        if (g.played) return;
        const res = simulateGame(g.home, g.away);
        g.played = true;
        g.homeScore = res.homeScore;
        g.awayScore = res.awayScore;
        g.winner = res.homeScore > res.awayScore ? g.home : g.away;
        results.push(formatResultLine(g));
      });

      // build divisional for this conference
      const seed1 = seedsByConference[conf].find((s) => s.seed === 1);
      const winners = games.map((g) => {
        const seed = seedsByConference[conf].find((s) => s.id === g.winner);
        return seed;
      });

      const divisionalGames = buildDivisionalRound(seed1, winners, conf);
      bracket.DIVISIONAL[conf] = divisionalGames;
    });

    return results.join("  ");
  }

  if (round === "DIVISIONAL") {
    const results = [];

    ["AFC", "NFC"].forEach((conf) => {
      const games = bracket.DIVISIONAL[conf];
      const winners = [];

      games.forEach((g) => {
        if (g.played) return;
        const res = simulateGame(g.home, g.away);
        g.played = true;
        g.homeScore = res.homeScore;
        g.awayScore = res.awayScore;
        g.winner = res.homeScore > res.awayScore ? g.home : g.away;
        winners.push(g.winner);
        results.push(formatResultLine(g));
      });

      // build conference championship for this conference
      if (winners.length === 2) {
        const [t1, t2] = winners;
        const s1 = season.playoffs.seedsByConference[conf].find(
          (s) => s.id === t1
        );
        const s2 = season.playoffs.seedsByConference[conf].find(
          (s) => s.id === t2
        );

        bracket.CONFERENCE[conf] = [
          {
            id: `${conf}-CONF-1`,
            round: "CONFERENCE",
            conference: conf,
            home: s1.seed < s2.seed ? t1 : t2,
            away: s1.seed < s2.seed ? t2 : t1,
            homeSeed: s1.seed < s2.seed ? s1.seed : s2.seed,
            awaySeed: s1.seed < s2.seed ? s2.seed : s1.seed,
            played: false,
            homeScore: null,
            awayScore: null,
            winner: null
          }
        ];
      }
    });

    return results.join("  ");
  }

  if (round === "CONFERENCE") {
    const results = [];
    const confWinners = {};

    ["AFC", "NFC"].forEach((conf) => {
      const games = bracket.CONFERENCE[conf];
      games.forEach((g) => {
        if (g.played) return;
        const res = simulateGame(g.home, g.away);
        g.played = true;
        g.homeScore = res.homeScore;
        g.awayScore = res.awayScore;
        g.winner = res.homeScore > res.awayScore ? g.home : g.away;
        confWinners[conf] = g.winner;
        results.push(formatResultLine(g));
      });
    });

    // build Super Bowl
    if (confWinners.AFC && confWinners.NFC) {
      const afcSeed = season.playoffs.seedsByConference.AFC.find(
        (s) => s.id === confWinners.AFC
      );
      const nfcSeed = season.playoffs.seedsByConference.NFC.find(
        (s) => s.id === confWinners.NFC
      );

      season.playoffs.bracket.SUPER_BOWL.GAME = {
        id: "SB-1",
        round: "SUPER_BOWL",
        conference: "CROSS",
        home: afcSeed.seed <= nfcSeed.seed ? confWinners.AFC : confWinners.NFC,
        away: afcSeed.seed <= nfcSeed.seed ? confWinners.NFC : confWinners.AFC,
        homeSeed: afcSeed.seed <= nfcSeed.seed ? afcSeed.seed : nfcSeed.seed,
        awaySeed: afcSeed.seed <= nfcSeed.seed ? nfcSeed.seed : afcSeed.seed,
        played: false,
        homeScore: null,
        awayScore: null,
        winner: null
      };
    }

    return results.join("  ");
  }

  if (round === "SUPER_BOWL") {
    const g = season.playoffs.bracket.SUPER_BOWL.GAME;
    if (!g || g.played) return "";

    const res = simulateGame(g.home, g.away);
    g.played = true;
    g.homeScore = res.homeScore;
    g.awayScore = res.awayScore;
    g.winner = res.homeScore > res.awayScore ? g.home : g.away;

    season.playoffs.champion = g.winner;

    return formatResultLine(g);
  }

  return "";
}

function buildDivisionalRound(seed1, wildcardWinners, conf) {
  // wildcardWinners: array of { id, seed }
  const seeds = wildcardWinners.map((s) => s.seed).sort((a, b) => a - b);
  // lowest remaining seed plays #1
  const lowestSeed = seeds[0];
  const otherSeeds = seeds.slice(1);

  const lowestTeam = wildcardWinners.find((s) => s.seed === lowestSeed);
  const [sA, sB] = otherSeeds;
  const teamA = wildcardWinners.find((s) => s.seed === sA);
  const teamB = wildcardWinners.find((s) => s.seed === sB);

  const games = [];

  // Game 1: #1 vs lowest remaining
  games.push({
    id: `${conf}-DIV-1`,
    round: "DIVISIONAL",
    conference: conf,
    home: seed1.id,
    away: lowestTeam.id,
    homeSeed: seed1.seed,
    awaySeed: lowestTeam.seed,
    played: false,
    homeScore: null,
    awayScore: null,
    winner: null
  });

  // Game 2: other two winners
  games.push({
    id: `${conf}-DIV-2`,
    round: "DIVISIONAL",
    conference: conf,
    home: teamA.seed < teamB.seed ? teamA.id : teamB.id,
    away: teamA.seed < teamB.seed ? teamB.id : teamA.id,
    homeSeed: teamA.seed < teamB.seed ? teamA.seed : teamB.seed,
    awaySeed: teamA.seed < teamB.seed ? teamB.seed : teamA.seed,
    played: false,
    homeScore: null,
    awayScore: null,
    winner: null
  });

  return games;
}

function formatResultLine(game) {
  const homeConf = getConference(game.home);
  
  const homeTeam = teams.find((t) => t.id === game.home);
  const awayTeam = teams.find((t) => t.id === game.away);

  const homeName = homeTeam
    ? `${homeTeam.city} ${homeTeam.mascot}`
    : game.home;
  const awayName = awayTeam
    ? `${awayTeam.city} ${awayTeam.mascot}`
    : game.away;

  return `${homeConf || ""} ${game.round}: ${homeName} ${game.homeScore} - ${awayName} ${game.awayScore}`;
}


****************************************

src/components/team/playoffs/PlayoffsTab.jsx:

// src/components/team/playoffs/PlayoffsTab.jsx
import React from "react";
import styles from "./PlayoffsTab.module.css";
import { teams } from "../../../data/teams";

export default function PlayoffsTab({ season, userTeamId }) {
  if (!season?.playoffs) {
    return (
      <div className={styles.container}>
        Playoffs have not been initialized yet.
      </div>
    );
  }

  const { bracket } = season.playoffs;

  const getTeamName = (id) => {
    const t = teams.find((x) => x.id === id);
    return t ? `${t.city} ${t.mascot}` : id;
  };

  const isUserTeam = (id) => id === userTeamId;

  const renderGame = (g) => {
    if (!g) return null;

    const played = g.played;
    const winner = played && (g.homeScore > g.awayScore ? g.home : g.away);

    const rowClass = (teamId) =>
      `${styles.teamRow} 
       ${winner === teamId ? styles.winner : ""} 
       ${isUserTeam(teamId) ? styles.userTeam : ""}`;

    return (
      <div key={g.id} className={styles.gameBox}>
        <div className={rowClass(g.home)}>
          <span className={styles.seed}>#{g.homeSeed}</span>
          <span>{getTeamName(g.home)}</span>
          {played && <span className={styles.score}>{g.homeScore}</span>}
        </div>

        <div className={rowClass(g.away)}>
          <span className={styles.seed}>#{g.awaySeed}</span>
          <span>{getTeamName(g.away)}</span>
          {played && <span className={styles.score}>{g.awayScore}</span>}
        </div>
      </div>
    );
  };

  // Build user team playoff run
  const userRun = [];
  ["WILDCARD", "DIVISIONAL", "CONFERENCE"].forEach((round) => {
    ["AFC", "NFC"].forEach((conf) => {
      const games = bracket[round]?.[conf] || [];
      games.forEach((g) => {
        if (g.home === userTeamId || g.away === userTeamId) {
          userRun.push({ round, game: g });
        }
      });
    });
  });

  const sbGame = bracket.SUPER_BOWL?.GAME;
  if (sbGame && (sbGame.home === userTeamId || sbGame.away === userTeamId)) {
    userRun.push({ round: "SUPER_BOWL", game: sbGame });
  }

  return (
    <div className={styles.container}>
      {userRun.length > 0 && (
        <div className={styles.userRunBox}>
          <div className={styles.userRunHeader}>Your Playoff Run</div>
          {userRun.map(({ round, game }) => (
            <div key={game.id} className={styles.userRunRow}>
              <strong>{round.replace("_", " ")}:</strong>
              <span>
                {getTeamName(game.home)} vs {getTeamName(game.away)}
              </span>
              {game.played && (
                <span className={styles.userRunScore}>
                  {game.homeScore} - {game.awayScore}
                </span>
              )}
            </div>
          ))}
        </div>
      )}

      <div className={styles.bracketGrid}>
        {/* AFC side */}
        <div className={styles.confColumn}>
          <div className={styles.confHeader}>AFC</div>

          {["WILDCARD", "DIVISIONAL", "CONFERENCE"].map((round) => (
            <div key={round} className={styles.roundSection}>
              <div className={styles.roundHeader}>
                {round.replace("_", " ")}
              </div>
              <div className={styles.roundGrid}>
                {(bracket[round]?.AFC || []).map((g) => renderGame(g))}
              </div>
            </div>
          ))}
        </div>

        {/* Super Bowl center */}
        <div className={styles.centerColumn}>
          <div className={styles.confHeader}>SUPER BOWL</div>
          <div className={styles.roundSection}>
            <div className={styles.roundHeader}>Championship</div>
            <div className={styles.roundGrid}>
              {sbGame ? renderGame(sbGame) : <div>No matchup yet.</div>}
            </div>
          </div>
        </div>

        {/* NFC side */}
        <div className={styles.confColumn}>
          <div className={styles.confHeader}>NFC</div>

          {["WILDCARD", "DIVISIONAL", "CONFERENCE"].map((round) => (
            <div key={round} className={styles.roundSection}>
              <div className={styles.roundHeader}>
                {round.replace("_", " ")}
              </div>
              <div className={styles.roundGrid}>
                {(bracket[round]?.NFC || []).map((g) => renderGame(g))}
              </div>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}


**************************************

src/components/team/playoffs/PlayoffsTab.module.css:

/* src/components/team/playoffs/PlayoffsTab.module.css */

.container {
  padding: 20px;
  background-color: #0f111a;
  border-radius: 12px;
  display: flex;
  flex-direction: column;
  gap: 24px;
  color: #fff;
}

/* ROUND HEADER */
.roundSection {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.roundHeader {
  font-size: 1.1rem;
  font-weight: 700;
  color: #00d4ff;
  border-bottom: 2px solid #00d4ff;
  padding-bottom: 4px;
}

/* GAME GRID */
.roundGrid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
  gap: 16px;
}

.gameBox {
  background: rgba(255, 255, 255, 0.06);
  border-radius: 10px;
  padding: 12px;
  display: flex;
  flex-direction: column;
  gap: 6px;
  transition: background 0.2s ease;
}

.gameBox:hover {
  background: rgba(0, 212, 255, 0.08);
}

.teamRow {
  display: grid;
  grid-template-columns: 40px 1fr 40px;
  align-items: center;
  font-size: 0.9rem;
}

.seed {
  color: #00d4ff;
  font-weight: 700;
}

.score {
  text-align: right;
  font-weight: 700;
}

.winner {
  color: #2ecc71;
  font-weight: 700;
}

.bracketGrid {
  display: grid;
  grid-template-columns: 1fr auto 1fr;
  gap: 20px;
}

.confColumn {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.centerColumn {
  display: flex;
  flex-direction: column;
  gap: 16px;
  align-items: center;
}

.confHeader {
  font-size: 1.1rem;
  font-weight: 700;
  color: #00d4ff;
  margin-bottom: 4px;
}

/* MOBILE */
@media (max-width: 768px) {
  .bracketGrid {
    grid-template-columns: 1fr;
  }
  .centerColumn {
    align-items: stretch;
  }
}

.userTeam {
  background: rgba(0, 212, 255, 0.15);
  border-left: 3px solid #00d4ff;
}

.userRunBox {
  background: rgba(255, 255, 255, 0.06);
  padding: 12px;
  border-radius: 10px;
  margin-bottom: 20px;
}

.userRunHeader {
  font-weight: 700;
  color: #00d4ff;
  margin-bottom: 6px;
}

.userRunRow {
  display: flex;
  justify-content: space-between;
  padding: 4px 0;
}

.userRunScore {
  font-weight: 700;
}

******************************


src/data/teams.js:

export const teams = [
  // -------------------- AFC NORTH --------------------
  { id: "BAL", city: "BAL", mascot: "Night Wings", conference: "AFC", division: "North", color: "#5A4FCF" },
  { id: "CIN", city: "CIN", mascot: "Striped Fury", conference: "AFC", division: "North", color: "#F77F2F" },
  { id: "CLE", city: "CLE", mascot: "Forge Hounds", conference: "AFC", division: "North", color: "#A65A2E" },
  { id: "PIT", city: "PIT", mascot: "Iron Hammers", conference: "AFC", division: "North", color: "#6E6E6E" },
  // -------------------- AFC EAST --------------------
  { id: "BUF", city: "BUF", mascot: "Frost Horns", conference: "AFC", division: "East", color: "#3A6FF7" },
  { id: "MIA", city: "MIA", mascot: "Neon Sharks", conference: "AFC", division: "East", color: "#00C9A7" },
  { id: "NE",  city: "NE",  mascot: "Rebel Rousers", conference: "AFC", division: "East", color: "#34495E" },
  { id: "NYJ", city: "NYJ", mascot: "Green Flight", conference: "AFC", division: "East", color: "#2ECC71" },
  // -------------------- AFC SOUTH --------------------
  { id: "HOU", city: "HOU", mascot: "Red Guardians", conference: "AFC", division: "South", color: "#C0392B" },
  { id: "IND", city: "IND", mascot: "Blue Chargers", conference: "AFC", division: "South", color: "#2E86DE" },
  { id: "JAX", city: "JAX", mascot: "Jungle Strikers", conference: "AFC", division: "South", color: "#D4A017" },
  { id: "TEN", city: "TEN", mascot: "Rail Breakers", conference: "AFC", division: "South", color: "#5DADE2" },
  // -------------------- AFC WEST --------------------
  { id: "DEN", city: "DEN", mascot: "Storm Riders", conference: "AFC", division: "West", color: "#FF7F50" },
  { id: "KC",  city: "KC",  mascot: "War Herd", conference: "AFC", division: "West", color: "#D63031" },
  { id: "LV",  city: "LV",  mascot: "Black Spades", conference: "AFC", division: "West", color: "#555555" },
  { id: "LAC", city: "LAC", mascot: "Volt Surge", conference: "AFC", division: "West", color: "#4DA6FF" },
  // -------------------- NFC NORTH --------------------
  { id: "CHI", city: "CHI", mascot: "War Dogs", conference: "NFC", division: "North", color: "#CA6F1E" },
  { id: "DET", city: "DET", mascot: "Motown Maulers", conference: "NFC", division: "North", color: "#5DADE2" },
  { id: "GB",  city: "GB",  mascot: "Green Machine", conference: "NFC", division: "North", color: "#27AE60" },
  { id: "MIN", city: "MIN", mascot: "Ice Wardens", conference: "NFC", division: "North", color: "#8E44AD" },
  // -------------------- NFC EAST --------------------
  { id: "DAL", city: "DAL", mascot: "Lone Stars", conference: "NFC", division: "East", color: "#2C3E50" },
  { id: "NYG", city: "NYG", mascot: "Empire Guardians", conference: "NFC", division: "East", color: "#3A6FF7" },
  { id: "PHI", city: "PHI", mascot: "Liberty Reign", conference: "NFC", division: "East", color: "#1ABC9C" },
  { id: "WAS", city: "WAS", mascot: "Capital Command", conference: "NFC", division: "East", color: "#884EA0" },
  // -------------------- NFC SOUTH --------------------
  { id: "ATL", city: "ATL", mascot: "Fire Birds", conference: "NFC", division: "South", color: "#E74C3C" },
  { id: "CAR", city: "CAR", mascot: "Black Claws", conference: "NFC", division: "South", color: "#2980B9" },
  { id: "NO",  city: "NO",  mascot: "Bayou Reapers", conference: "NFC", division: "South", color: "#D4AC0D" },
  { id: "TB",  city: "TB",  mascot: "Bay Pirates", conference: "NFC", division: "South", color: "#C0392B" },
  // -------------------- NFC WEST --------------------
  { id: "ARI", city: "ARI", mascot: "Red Talons", conference: "NFC", division: "West", color: "#C0392B" },
  { id: "LAR", city: "LAR", mascot: "Coast Crashers", conference: "NFC", division: "West", color: "#F1C40F" },
  { id: "SF",  city: "SF",  mascot: "Gold Rush", conference: "NFC", division: "West", color: "#D68910" },
  { id: "SEA", city: "SEA", mascot: "Rain Makers", conference: "NFC", division: "West", color: "#2ECC71" }
];


*****************************************************8


src/utils/scheduleGenerator.js:

// src/utils/scheduleGenerator.js

import { teams } from "../data/teams";

/**
 * PUBLIC API
 * Deterministic, NFL-style schedule generator.
 * - 17 games + 1 bye per team
 * - 6 division games (home/away vs 3 rivals)
 * - 4 intraconference rotation games
 * - 4 interconference rotation games
 * - 2 strength-of-schedule games (same-place, same conference)
 * - 1 cross-conference 17th game (same-place, different division than inter-rotation)
 * - No duplicate non-division opponents
 * - No back-to-back vs same opponent
 * - 18 weeks, exactly 1 bye per team
 */
export function generateSeasonSchedule(year) {
  const divisions = buildDivisionStructure();
  const ranks = buildDivisionRanks(divisions); // pseudo-standings, deterministic

  // 1) Build opponent lists (no weeks yet)
  const schedule = {};
  teams.forEach((t) => {
    schedule[t.id] = [];
  });

  // Division games (6)
  addDivisionGames(schedule, divisions);

  // Intra-conference rotation (4)
  addIntraConferenceRotationGames(schedule, divisions, year);

  // Inter-conference rotation (4)
  addInterConferenceRotationGames(schedule, divisions, year);

  // Strength-of-schedule (2)
  addStrengthOfScheduleGames(schedule, divisions, ranks, year);

  // 17th game (1)
  addSeventeenthGame(schedule, divisions, ranks, year);

  // 2) Assign weeks + byes
  assignWeeksAndByes(schedule, year);

  // 3) Sort each team schedule by week
  for (const teamId in schedule) {
    schedule[teamId].sort((a, b) => a.week - b.week);
  }

  return schedule;
}

/* ======================================================
   DIVISION / RANK HELPERS
====================================================== */

function buildDivisionStructure() {
  const divisions = {
    AFC: {
      North: [],
      East: [],
      South: [],
      West: []
    },
    NFC: {
      North: [],
      East: [],
      South: [],
      West: []
    }
  };

  teams.forEach((t) => {
    divisions[t.conference][t.division].push(t.id);
  });

  // Ensure deterministic ordering
  for (const conf of ["AFC", "NFC"]) {
    for (const div of ["North", "East", "South", "West"]) {
      divisions[conf][div].sort();
    }
  }

  return divisions;
}

// Pseudo-standings: alphabetical order within division = prior-year rank
// rank 0 = 1st place, 1 = 2nd, etc.
function buildDivisionRanks(divisions) {
  const ranks = {};
  for (const conf of ["AFC", "NFC"]) {
    ranks[conf] = {};
    for (const div of ["North", "East", "South", "West"]) {
      const list = divisions[conf][div];
      ranks[conf][div] = {};
      list.forEach((teamId, idx) => {
        ranks[conf][div][teamId] = idx; // 0–3
      });
    }
  }
  return ranks;
}

/* ======================================================
   GAME CREATION HELPERS
====================================================== */

function createEmptyGame({ week = null, type = "REGULAR_SEASON", opponent, home }) {
  return {
    week,
    type,
    opponent,
    home,
    played: false,
    scoreFor: null,
    scoreAgainst: null,
    result: null,
    overtime: false,
    attendance: null,
    notes: null
  };
}

function addGamePair(schedule, homeTeam, awayTeam) {
  // Home entry
  schedule[homeTeam].push(
    createEmptyGame({
      opponent: awayTeam,
      home: true
    })
  );
  // Away entry
  schedule[awayTeam].push(
    createEmptyGame({
      opponent: homeTeam,
      home: false
    })
  );
}

/* ======================================================
   DIVISION GAMES (6 per team)
====================================================== */

function addDivisionGames(schedule, divisions) {
  for (const conf of ["AFC", "NFC"]) {
    for (const div of ["North", "East", "South", "West"]) {
      const list = divisions[conf][div]; // 4 teams
      // Round-robin, home/away
      for (let i = 0; i < list.length; i++) {
        for (let j = i + 1; j < list.length; j++) {
          const t1 = list[i];
          const t2 = list[j];
          // One game with t1 home, one with t2 home
          addGamePair(schedule, t1, t2);
          addGamePair(schedule, t2, t1);
        }
      }
    }
  }
}

/* ======================================================
   ROTATION TABLES
   - These are structural, not tied to real NFL years,
     but follow the same formula: 3-year intra, 4-year inter.
====================================================== */

// Intra-conference rotation (3-year cycle)
// For each yearIndex (0,1,2), define pairings within a conference.
const INTRA_ROTATION = {
  AFC: [
    // yearIndex 0
    {
      North: "East",
      East: "North",
      South: "West",
      West: "South"
    },
    // yearIndex 1
    {
      North: "South",
      South: "North",
      East: "West",
      West: "East"
    },
    // yearIndex 2
    {
      North: "West",
      West: "North",
      East: "South",
      South: "East"
    }
  ],
  NFC: [
    // yearIndex 0
    {
      North: "East",
      East: "North",
      South: "West",
      West: "South"
    },
    // yearIndex 1
    {
      North: "South",
      South: "North",
      East: "West",
      West: "East"
    },
    // yearIndex 2
    {
      North: "West",
      West: "North",
      East: "South",
      South: "East"
    }
  ]
};

// Inter-conference rotation (4-year cycle)
// Pair each AFC division with an NFC division.
const INTER_ROTATION = [
  // yearIndex 0
  {
    AFC: {
      North: "North",
      East: "East",
      South: "South",
      West: "West"
    },
    NFC: {
      North: "North",
      East: "East",
      South: "South",
      West: "West"
    }
  },
  // yearIndex 1
  {
    AFC: {
      North: "East",
      East: "South",
      South: "West",
      West: "North"
    },
    NFC: {
      North: "West",
      East: "North",
      South: "East",
      West: "South"
    }
  },
  // yearIndex 2
  {
    AFC: {
      North: "South",
      East: "West",
      South: "North",
      West: "East"
    },
    NFC: {
      North: "South",
      East: "North",
      South: "West",
      West: "East"
    }
  },
  // yearIndex 3
  {
    AFC: {
      North: "West",
      East: "North",
      South: "East",
      West: "South"
    },
    NFC: {
      North: "East",
      East: "South",
      South: "North",
      West: "West"
    }
  }
];

// 17th game cross-conference division mapping (4-year cycle)
// Must be different from that year's INTER_ROTATION division.
const EXTRA17_ROTATION = [
  // yearIndex 0
  {
    AFC: {
      North: "South",
      East: "West",
      South: "North",
      West: "East"
    },
    NFC: {
      North: "South",
      East: "West",
      South: "North",
      West: "East"
    }
  },
  // yearIndex 1
  {
    AFC: {
      North: "West",
      East: "North",
      South: "East",
      West: "South"
    },
    NFC: {
      North: "East",
      East: "South",
      South: "North",
      West: "West"
    }
  },
  // yearIndex 2
  {
    AFC: {
      North: "East",
      East: "South",
      South: "West",
      West: "North"
    },
    NFC: {
      North: "West",
      East: "North",
      South: "East",
      West: "South"
    }
  },
  // yearIndex 3
  {
    AFC: {
      North: "North",
      East: "East",
      South: "South",
      West: "West"
    },
    NFC: {
      North: "North",
      East: "East",
      South: "South",
      West: "West"
    }
  }
];

function getIntraRotationYearIndex(year) {
  // 3-year cycle starting at 2026
  return (year - 2026) % 3;
}

function getInterRotationYearIndex(year) {
  // 4-year cycle starting at 2026
  return (year - 2026) % 4;
}

/* ======================================================
   INTRA-CONFERENCE ROTATION GAMES (4 per team)
====================================================== */

function addIntraConferenceRotationGames(schedule, divisions, year) {
  const idx = getIntraRotationYearIndex(year);

  for (const conf of ["AFC", "NFC"]) {
    const mapping = INTRA_ROTATION[conf][idx];

    // To avoid double-processing, only handle when division name is "North" or "East"
    // and let the mapping handle the symmetric partner.
    for (const div of ["North", "East", "South", "West"]) {
      const partnerDiv = mapping[div];
      if (!partnerDiv) continue;

      // Process each pair only once
      if (!shouldProcessDivisionPair(div, partnerDiv)) continue;

      const divTeams = divisions[conf][div];
      const partnerTeams = divisions[conf][partnerDiv];

      // Full bipartite: each team plays all 4 teams in the other division
      for (let i = 0; i < divTeams.length; i++) {
        for (let j = 0; j < partnerTeams.length; j++) {
          const t1 = divTeams[i];
          const t2 = partnerTeams[j];

          // Deterministic home/away: alternate by indices + year
          const homeFirst =
            ((i + j + year) % 2 === 0) ? t1 : t2;
          const awayFirst = homeFirst === t1 ? t2 : t1;

          addGamePair(schedule, homeFirst, awayFirst);
        }
      }
    }
  }
}

function shouldProcessDivisionPair(divA, divB) {
  // Ensure each unordered pair is processed once
  const order = ["North", "East", "South", "West"];
  const idxA = order.indexOf(divA);
  const idxB = order.indexOf(divB);
  return idxA < idxB;
}

/* ======================================================
   INTER-CONFERENCE ROTATION GAMES (4 per team)
====================================================== */

function addInterConferenceRotationGames(schedule, divisions, year) {
  const idx = getInterRotationYearIndex(year);
  const mapping = INTER_ROTATION[idx];

  // AFC vs NFC
  for (const afcDiv of ["North", "East", "South", "West"]) {
    const nfcDiv = mapping.AFC[afcDiv];
    const afcTeams = divisions.AFC[afcDiv];
    const nfcTeams = divisions.NFC[nfcDiv];

    // Full bipartite: each AFC team plays all 4 NFC teams
    for (let i = 0; i < afcTeams.length; i++) {
      for (let j = 0; j < nfcTeams.length; j++) {
        const afcTeam = afcTeams[i];
        const nfcTeam = nfcTeams[j];

        // Deterministic home/away: alternate by indices + year
        const homeFirst =
          ((i + j + year) % 2 === 0) ? afcTeam : nfcTeam;
        const awayFirst = homeFirst === afcTeam ? nfcTeam : afcTeam;

        addGamePair(schedule, homeFirst, awayFirst);
      }
    }
  }
}

/* ======================================================
   STRENGTH-OF-SCHEDULE GAMES (2 per team)
   - Same-place finishers from the two divisions in the
     same conference that are NOT the intra-rotation division.
   - Uses pseudo-ranks (alphabetical) as prior-year standings.
====================================================== */

function addStrengthOfScheduleGames(schedule, divisions, ranks, year) {
  const intraIdx = getIntraRotationYearIndex(year);

  for (const conf of ["AFC", "NFC"]) {
    const intraMap = INTRA_ROTATION[conf][intraIdx];

    const allDivs = ["North", "East", "South", "West"];

    for (const div of allDivs) {
      const intraPartner = intraMap[div];
      const otherDivs = allDivs.filter(
        (d) => d !== div && d !== intraPartner
      ); // 2 divisions

      const baseTeams = divisions[conf][div];

      baseTeams.forEach((teamId) => {
        const rank = ranks[conf][div][teamId]; // 0–3

        otherDivs.forEach((otherDiv, idx) => {
          const otherTeams = divisions[conf][otherDiv];
          const opponentId = otherTeams[rank];

          // Deterministic home/away: alternate by idx + year
          const homeFirst =
            ((rank + idx + year) % 2 === 0) ? teamId : opponentId;
          const awayFirst = homeFirst === teamId ? opponentId : teamId;

          // To avoid duplicates, only create if teamId is "lexicographically smaller"
          if (teamId < opponentId) {
            addGamePair(schedule, homeFirst, awayFirst);
          }
        });
      });
    }
  }
}

/* ======================================================
   17th GAME (1 per team)
   - Cross-conference, same-place finisher
   - Division mapping from EXTRA17_ROTATION
====================================================== */

function addSeventeenthGame(schedule, divisions, ranks, year) {
  const idx = getInterRotationYearIndex(year);
  const mapping = EXTRA17_ROTATION[idx];

  // AFC side
  for (const afcDiv of ["North", "East", "South", "West"]) {
    const nfcDiv = mapping.AFC[afcDiv];
    const afcTeams = divisions.AFC[afcDiv];
    const nfcTeams = divisions.NFC[nfcDiv];

    afcTeams.forEach((afcTeamId) => {
      const rank = ranks.AFC[afcDiv][afcTeamId];
      const nfcTeamId = nfcTeams[rank];

      // Deterministic home/away:
      // Let AFC host in even years, NFC host in odd years
      const afcHosts = year % 2 === 0;
      const homeFirst = afcHosts ? afcTeamId : nfcTeamId;
      const awayFirst = afcHosts ? nfcTeamId : afcTeamId;

      // Avoid duplicates: only create if AFC team id < NFC team id
      const keyA = `A-${afcTeamId}`;
      const keyB = `N-${nfcTeamId}`;
      if (keyA < keyB) {
        addGamePair(schedule, homeFirst, awayFirst);
      }
    });
  }
}

/* ======================================================
   WEEK + BYE ASSIGNMENT
   - 18 weeks
   - 17 games + 1 bye per team
   - No back-to-back vs same opponent when possible
====================================================== */

function assignWeeksAndByes(schedule, year) {
  const teamIds = Object.keys(schedule).sort();

  // Precompute bye weeks (5–14) deterministically
  const byeWeeks = {};
  teamIds.forEach((teamId, idx) => {
    const bye = 5 + ((year + idx) % 10); // 5–14
    byeWeeks[teamId] = bye;
  });

  // Build list of unique matchups
  const games = [];
  const seenPairs = new Set();

  for (const teamId of teamIds) {
    schedule[teamId].forEach((g) => {
      if (g.type !== "REGULAR_SEASON" || g.opponent == null) return;
      const pairKey = makePairKey(teamId, g.opponent);
      if (seenPairs.has(pairKey)) return;
      seenPairs.add(pairKey);

      // Determine canonical home/away from one of the entries
      const homeEntry = schedule[teamId].find(
        (x) =>
          x.opponent === g.opponent &&
          x.type === "REGULAR_SEASON" &&
          x.home === true
      );
      const homeTeam = homeEntry ? teamId : g.opponent;
      const awayTeam = homeEntry ? g.opponent : teamId;

      games.push({
        home: homeTeam,
        away: awayTeam,
        week: null
      });
    });
  }

  // Deterministic ordering of games
  games.sort((a, b) => {
    const ka = `${a.home}-${a.away}`;
    const kb = `${b.home}-${b.away}`;
    return ka.localeCompare(kb);
  });

  // Track per-team week occupancy and last opponent
  const teamWeek = {};
  const lastOpponentByWeek = {};
  teamIds.forEach((id) => {
    teamWeek[id] = {};
    lastOpponentByWeek[id] = {};
  });

  const TOTAL_WEEKS = 18;

  // Greedy assignment: for each game, find earliest valid week
  for (const game of games) {
    let assigned = false;

    for (let week = 1; week <= TOTAL_WEEKS; week++) {
      const home = game.home;
      const away = game.away;

      if (week === byeWeeks[home] || week === byeWeeks[away]) continue;
      if (teamWeek[home][week] || teamWeek[away][week]) continue;

      const prevWeek = week - 1;
      if (
        prevWeek >= 1 &&
        (lastOpponentByWeek[home][prevWeek] === away ||
          lastOpponentByWeek[away][prevWeek] === home)
      ) {
        // Would create back-to-back vs same opponent; try another week
        continue;
      }

      // Assign
      game.week = week;
      teamWeek[home][week] = true;
      teamWeek[away][week] = true;
      lastOpponentByWeek[home][week] = away;
      lastOpponentByWeek[away][week] = home;
      assigned = true;
      break;
    }

    // Fallback: if we couldn't avoid back-to-back, place it anywhere free
    if (!assigned) {
      for (let week = 1; week <= TOTAL_WEEKS; week++) {
        const home = game.home;
        const away = game.away;

        if (week === byeWeeks[home] || week === byeWeeks[away]) continue;
        if (teamWeek[home][week] || teamWeek[away][week]) continue;

        game.week = week;
        teamWeek[home][week] = true;
        teamWeek[away][week] = true;
        lastOpponentByWeek[home][week] = away;
        lastOpponentByWeek[away][week] = home;
        assigned = true;
        break;
      }
    }

    if (!assigned) {
      // This should be extremely rare; if it happens, we just drop the game.
      // But with 18 weeks and 17 games, the greedy algorithm should succeed.
      console.warn(
        "[scheduleGenerator] Failed to assign week for game:",
        game.home,
        "vs",
        game.away
      );
    }
  }

  // Now write weeks back into each team's schedule and add BYE entries
  for (const teamId of teamIds) {
    const byeWeek = byeWeeks[teamId];

    // Map opponent -> list of weeks for this team
    const gameWeeksByOpponent = {};

    games.forEach((g) => {
      if (g.week == null) return;
      if (g.home === teamId || g.away === teamId) {
        const opp = g.home === teamId ? g.away : g.home;
        if (!gameWeeksByOpponent[opp]) gameWeeksByOpponent[opp] = [];
        gameWeeksByOpponent[opp].push(g.week);
      }
    });

    // Assign weeks to schedule entries
    schedule[teamId].forEach((g) => {
      if (g.type !== "REGULAR_SEASON" || g.opponent == null) return;
      const opp = g.opponent;
      const list = gameWeeksByOpponent[opp] || [];
      if (list.length === 0) return;
      const week = list.shift();
      g.week = week;
    });

    // Add BYE entry
    schedule[teamId].push({
      week: byeWeek,
      type: "REGULAR_SEASON",
      opponent: null,
      home: true,
      played: false,
      scoreFor: null,
      scoreAgainst: null,
      result: "BYE",
      overtime: false,
      attendance: null,
      notes: null
    });
  }
}

function makePairKey(a, b) {
  return [a, b].sort().join("-");
}


/* ======================================================
   SCHEDULE TEST HARNESS (runs every season initialization)
   Prints one clean summary line per team.
====================================================== */

function runScheduleTest(schedule, divisions, year) {
  console.log(`\n===== SCHEDULE TEST — YEAR ${year} =====`);

  const teams = Object.keys(schedule).sort();

  for (const teamId of teams) {
    const result = analyzeTeamSchedule(teamId, schedule, divisions, year);
    const prefix = `[SCHEDULE TEST] ${teamId} —`;

    if (result.ok) {
      console.log(
        `${prefix} OK ` +
          `(div ${result.div}, intra ${result.intra}, inter ${result.inter}, sos ${result.sos}, extra ${result.extra})`
      );
    } else {
      console.log(`${prefix} ERROR: ${result.error}`);
    }
  }

  console.log("===== END SCHEDULE TEST =====\n");
}

function analyzeTeamSchedule(teamId, schedule, divisions, year) {
  const games = schedule[teamId].filter((g) => g.type === "REGULAR_SEASON" && g.opponent);

  const divInfo = findTeamDivision(teamId, divisions);
  const { conference, division } = divInfo;


  // Count categories
  let div = 0;
  let intra = 0;
  let inter = 0;
  let sos = 0;
  let extra = 0;

  const seen = new Set();

  for (const g of games) {
    const opp = g.opponent;

    // Duplicate check
    const key = [teamId, opp].sort().join("-");
    if (seen.has(key)) {
      return { ok: false, error: `duplicate opponent ${opp}` };
    }
    seen.add(key);

    const oppInfo = findTeamDivision(opp, divisions);

    if (oppInfo.conference === conference && oppInfo.division === division) {
      div++;
    } else if (oppInfo.conference === conference) {
      // Same conference, different division
      // Need to determine if this division was the intra-rotation partner
      const intraPartner = getIntraPartner(conference, division, year);
      if (oppInfo.division === intraPartner) {
        intra++;
      } else {
        sos++;
      }
    } else {
      // Opponent is in the other conference
      const interPartner = getInterPartner(conference, division, year);
      const extraPartner = getExtra17Partner(conference, division, year);

      if (oppInfo.division === interPartner) {
        inter++;
      } else if (oppInfo.division === extraPartner) {
        extra++;
      } else {
        return { ok: false, error: `unexpected cross-conference opponent ${opp}` };
      }
    }
  }

  // Validate counts
  if (div !== 6) return { ok: false, error: `division count ${div} != 6` };
  if (intra !== 4) return { ok: false, error: `intra count ${intra} != 4` };
  if (inter !== 4) return { ok: false, error: `inter count ${inter} != 4` };
  if (sos !== 2) return { ok: false, error: `sos count ${sos} != 2` };
  if (extra !== 1) return { ok: false, error: `extra count ${extra} != 1` };

  return { ok: true, div, intra, inter, sos, extra };
}

function findTeamDivision(teamId, divisions) {
  for (const conf of ["AFC", "NFC"]) {
    for (const div of ["North", "East", "South", "West"]) {
      if (divisions[conf][div].includes(teamId)) {
        return { conference: conf, division: div };
      }
    }
  }
  throw new Error("Team not found in divisions: " + teamId);
}

// These three helpers must match your rotation tables in the generator:
function getIntraPartner(conf, div, year) {
  const idx = (year - 2026) % 3;
  const map = {
    0: { North: "East", East: "North", South: "West", West: "South" },
    1: { North: "South", South: "North", East: "West", West: "East" },
    2: { North: "West", West: "North", East: "South", South: "East" }
  };
  return map[idx][div];
}

function getInterPartner(conf, div, year) {
  const idx = (year - 2026) % 4;
  const map = {
    0: { North: "North", East: "East", South: "South", West: "West" },
    1: { North: "East", East: "South", South: "West", West: "North" },
    2: { North: "South", East: "West", South: "North", West: "East" },
    3: { North: "West", East: "North", South: "East", West: "South" }
  };
  return map[idx][div];
}

function getExtra17Partner(conf, div, year) {
  const idx = (year - 2026) % 4;
  const map = {
    0: { North: "South", East: "West", South: "North", West: "East" },
    1: { North: "West", East: "North", South: "East", West: "South" },
    2: { North: "East", East: "South", South: "West", West: "North" },
    3: { North: "North", East: "East", South: "South", West: "West" }
  };
  return map[idx][div];
}

/* ======================================================
   SCHEDULE TEST HARNESS WRAPPER (lint-safe)
   Runs every time generateSeasonSchedule() is called.
====================================================== */

export function runScheduleTestWrapper(schedule, year) {
  try {
    const divisions = buildDivisionStructure();
    runScheduleTest(schedule, divisions, year);
  } catch (err) {
    console.error("[SCHEDULE TEST] Harness error:", err);
  }
}




**************************************************************************


src/utils/gamesim.js:

// src/utils/gameSim.js
//
// Roster- and coach-weighted game simulation.
// This file is intentionally engine-agnostic: it does NOT import React or seasonEngine.
// You pass in the data it needs from wherever you call it.

function avgOverall(players) {
  if (!players || players.length === 0) return 0;
  const sum = players.reduce((s, p) => s + (p.ratings?.overall ?? 0), 0);
  return sum / players.length;
}

function pickStarter(players, position) {
  if (!players) return null;
  const filtered = players.filter(
    (p) => p.position === position && (p.depth === 1 || p.depth === 0 || p.depth == null)
  );
  if (filtered.length === 0) return null;
  // If multiple "starters", just take the highest overall
  return filtered.reduce((best, p) =>
    (p.ratings?.overall ?? 0) > (best.ratings?.overall ?? 0) ? p : best
  );
}

function filterByPosition(roster, positions) {
  if (!roster) return [];
  return roster.filter((p) => positions.includes(p.position));
}

// Simple Box–Muller normal distribution
function randomNormal(mean = 0, stdDev = 1) {
  let u = 0,
    v = 0;
  while (u === 0) u = Math.random();
  while (v === 0) v = Math.random();
  const z = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
  return mean + z * stdDev;
}

function computeTeamStrength({ roster, coachRating = 75, isHome = false }) {
  if (!roster || roster.length === 0) {
    // Failsafe: treat as expansion-level team
    return 60 + (coachRating - 75) * 0.2 + (isHome ? 1.0 : 0);
  }

  const qb = pickStarter(roster, "QB");
  const rbs = filterByPosition(roster, ["RB", "HB", "FB"]);
  const wrs = filterByPosition(roster, ["WR"]);
  const tes = filterByPosition(roster, ["TE"]);
  const ol = filterByPosition(roster, ["LT", "LG", "C", "RG", "RT", "OL"]);

  const dl = filterByPosition(roster, ["DE", "DT", "DL"]);
  const lbs = filterByPosition(roster, ["LB", "MLB", "OLB"]);
  const cbs = filterByPosition(roster, ["CB"]);
  const ss = filterByPosition(roster, ["SS", "FS", "S"]);

  const ks = filterByPosition(roster, ["K"]);
  const ps = filterByPosition(roster, ["P"]);

  const offenseRating =
    (qb?.ratings?.overall ?? 60) * 0.30 +
    avgOverall(rbs) * 0.08 +
    avgOverall(wrs) * 0.18 +
    (tes[0]?.ratings?.overall ?? avgOverall(tes)) * 0.06 +
    avgOverall(ol) * 0.20;

  const defenseRating =
    avgOverall(dl) * 0.07 +
    avgOverall(lbs) * 0.07 +
    avgOverall(cbs) * 0.08 +
    avgOverall(ss) * 0.06;

  const specialRating =
    ((ks[0]?.ratings?.overall ?? avgOverall(ks)) +
      (ps[0]?.ratings?.overall ?? avgOverall(ps))) /
    2 *
    0.02;

  const baseStrength = offenseRating + defenseRating + specialRating;

  // Coach influence: 0–100 → ±5 points swing
  const coachAdj = (coachRating - 75) * 0.2;

  // Home field: small but meaningful bump
  const homeAdj = isHome ? 2.0 : 0.0;

  return baseStrength + coachAdj + homeAdj;
}

/**
 * simulateWeightedGame
 *
 * @param {Object} params
 * @param {string} params.homeTeamId
 * @param {string} params.awayTeamId
 * @param {Object<string,Array>} params.rostersByTeam - map of teamId → roster array
 * @param {Object<string,number>} [params.coachRatingsByTeam] - map of teamId → coach overall (0–100)
 * @param {number} [params.chaosStdDev=5] - higher = more upsets/variance
 *
 * @returns {{
 *   homeScore: number,
 *   awayScore: number,
 *   homeStrength: number,
 *   awayStrength: number,
 *   upset: boolean
 * }}
 */
export function simulateWeightedGame({
  homeTeamId,
  awayTeamId,
  rostersByTeam,
  coachRatingsByTeam = {},
  chaosStdDev = 5
}) {
  const homeRoster = rostersByTeam[homeTeamId] || [];
  const awayRoster = rostersByTeam[awayTeamId] || [];

  const homeCoach = coachRatingsByTeam[homeTeamId] ?? 75;
  const awayCoach = coachRatingsByTeam[awayTeamId] ?? 75;

  const homeStrength = computeTeamStrength({
    roster: homeRoster,
    coachRating: homeCoach,
    isHome: true
  });

  const awayStrength = computeTeamStrength({
    roster: awayRoster,
    coachRating: awayCoach,
    isHome: false
  });

  // Add randomness around each strength
  const homeScoreRaw = homeStrength / 4 + randomNormal(0, chaosStdDev);
  const awayScoreRaw = awayStrength / 4 + randomNormal(0, chaosStdDev);

  // Clamp and round to football-ish scores
  const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
  let homeScore = Math.round(clamp(homeScoreRaw, 10, 45));
  let awayScore = Math.round(clamp(awayScoreRaw, 10, 45));

  // Avoid ties for now (you can relax this later)
  if (homeScore === awayScore) {
    if (Math.random() < 0.5) homeScore += 3;
    else awayScore += 3;
  }

  const favored =
    homeStrength === awayStrength
      ? null
      : homeStrength > awayStrength
      ? "HOME"
      : "AWAY";

  const actualWinner =
    homeScore === awayScore ? null : homeScore > awayScore ? "HOME" : "AWAY";

  const upset =
    favored !== null && actualWinner !== null && favored !== actualWinner;

  return {
    homeScore,
    awayScore,
    homeStrength,
    awayStrength,
    upset
  };
}


***************************************************


src/components/team/TeamTabs.jsx:

// src/components/team/TeamTabs.jsx
import React from "react";
import styles from "./TeamTabs.module.css";

export default function TeamTabs({ tab, setTab }) {
  const tabs = [
    { key: "roster", label: "Roster" },
    { key: "depthChart", label: "Depth Chart" },
    { key: "staff", label: "Staff" },
    { key: "finances", label: "Finances" },
    { key: "schedule", label: "Schedule" },
    { key: "Standings", label: "Standings" },
    { key: "playoffs", label: "Playoffs" }, // NEW TAB
    { key: "stats", label: "Stats" }
  ];

  return (
    <div className={styles.tabRow}>
      {tabs.map((t) => (
        <div
          key={t.key}
          className={`${styles.tab} ${tab === t.key ? styles.active : ""}`}
          onClick={() => setTab(t.key)}
        >
          {t.label}
        </div>
      ))}
    </div>
  );
}


********************************************************************8

